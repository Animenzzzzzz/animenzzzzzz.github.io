<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Clustering - Part 3 | My Dearest</title><meta name="author" content="Animenzzzzzz"><meta name="copyright" content="Animenzzzzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Intro If you tried to compile the code from tutorial 28, you probably saw a lot of errors about not being able to send Strings across mpsc channels. The reasons behind this is worth a paragraph or">
<meta property="og:type" content="article">
<meta property="og:title" content="Clustering - Part 3">
<meta property="og:url" content="https://animenzzzzzz.github.io/pages/build-your-own-vm/29/index.html">
<meta property="og:site_name" content="My Dearest">
<meta property="og:description" content="Intro If you tried to compile the code from tutorial 28, you probably saw a lot of errors about not being able to send Strings across mpsc channels. The reasons behind this is worth a paragraph or">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://animenzzzzzz.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-01-03T05:44:17.000Z">
<meta property="article:modified_time" content="2025-01-03T07:37:20.542Z">
<meta property="article:author" content="Animenzzzzzz">
<meta property="article:tag" content="virtual-machine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://animenzzzzzz.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://animenzzzzzz.github.io/pages/build-your-own-vm/29/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Clustering - Part 3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 15:37:20'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a href="/" title="My Dearest"><span class="site-name">My Dearest</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Clustering - Part 3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-03T05:44:17.000Z" title="发表于 2025-01-03 13:44:17">2025-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-03T07:37:20.542Z" title="更新于 2025-01-03 15:37:20">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer/">Computer</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer/Virtual-Machine/">Virtual Machine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Clustering - Part 3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="intro">Intro</h2>
<p>If you tried to compile the code from tutorial 28, you probably saw a
lot of errors about not being able to send Strings across mpsc channels.
The reasons behind this is worth a paragraph or three on why.</p>
<h3 id="mpsc-channels">mpsc Channels</h3>
<p>In Rust, we have something called mpsc channels, or multi-producer
single-consumer. Think of it as a 100 people talking to 1 person. That 1
person receives and processes each message.</p>
<p>Here’s a simple example of creating a channel:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And that’s it! A few things to note, though:</p>
<ol type="1">
<li>The <code>tx</code> variable is the producer (or transmit) side</li>
<li>The <code>rx</code> variable is the consumer (or receiver) side</li>
</ol>
<h3 id="simple-usage-example">Simple Usage Example</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rx got: &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="the-multi-part">The Multi Part</h2>
<p>There’s a big difference between the tx side and the rx side: you can
do <code>let other_sender = tx.clone()</code>. Then anything you send
down that will go to the same receiver.</p>
<p>A common way to handle that is to have the receiver loop forever,
something like:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(msg) = rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">       <span class="title function_ invoke__">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We CANNOT clone the rx end like we can the tx end. We can only move
it.</p>
</blockquote>
<p>The <code>recv()</code> call blocks, so we won’t burn CPU. Whenever a
message arrives, we just handle it.</p>
<h2 id="our-problem">Our Problem</h2>
<p>We need a central repository of clients per VM. But we listen for
those clients on separate threads. Those errors the compiler is showing
us indicate a fundamental flaw in our architecture.</p>
<blockquote>
<p>The Rust model of ownership is a pretty good model in general, and
the strictness of the compiler helps enforce architectures that tend to
be decent.</p>
</blockquote>
<h3 id="the-manager">The Manager</h3>
<p>We have this connection manager struct. And right now, one VM binds
to one socket. Which means each VM needs a manager. So let’s address
that first. In <code>vm.rs</code>, add a field:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> connection_manager: Arc&lt;RwLock&lt;Manager&gt;&gt;,</span><br></pre></td></tr></table></figure>
<p>Note that we wrap it in a Arc and RwLock so that all of our client
threads can access it. Down in the <code>new()</code> function for the
<code>VM</code>, add this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection_manager: Arc::<span class="title function_ invoke__">new</span>(RwLock::<span class="title function_ invoke__">new</span>(Manager::<span class="title function_ invoke__">new</span>())),</span><br></pre></td></tr></table></figure>
<p>You probably see an error like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `std::sync::mpsc::Sender&lt;std::string::String&gt;` cannot be shared between threads safely</span><br><span class="line">  --&gt; src/scheduler/mod.rs:20:9</span><br><span class="line">   |</span><br><span class="line">20 |         thread::spawn(move || &#123;</span><br><span class="line">   |         ^^^^^^^^^^^^^ `std::sync::mpsc::Sender&lt;std::string::String&gt;` cannot be shared between threads safely</span><br><span class="line">error[E0277]: `std::sync::mpsc::Sender&lt;std::string::String&gt;` cannot be shared between threads safely</span><br><span class="line">  --&gt; src/scheduler/mod.rs:20:9</span><br><span class="line">   |</span><br><span class="line">20 |         thread::spawn(move || &#123;</span><br><span class="line">   |         ^^^^^^^^^^^^^ `std::sync::mpsc::Sender&lt;std::string::String&gt;` cannot be shared between threads safely</span><br><span class="line">   |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Our problematic function is this one:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Takes a VM and runs it in a background thread</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_thread</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> vm: VM) <span class="punctuation">-&gt;</span> thread::JoinHandle&lt;<span class="type">Vec</span>&lt;VMEvent&gt;&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">events</span> = vm.<span class="title function_ invoke__">run</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;VM Events&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> &amp;events &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, event);</span><br><span class="line">        &#125;</span><br><span class="line">        events</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is trying to move a VM into a thread so it can start executing.
But the VM contains a Manager, which contains ClusterClients, which
contain mpsc channels. And remember, we can’t send those willy-nilly
across threads.</p>
<p>For fun, let’s see what happens if we wrap the channels in
<code>Arc&lt;Mutex&lt;&gt;&gt;</code>. In
<code>src/cluster/client.rs</code> let’s replace:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rx: <span class="type">Option</span>&lt;Receiver&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">tx: <span class="type">Option</span>&lt;Sender&lt;<span class="type">String</span>&gt;&gt;,</span><br></pre></td></tr></table></figure>
<p>with:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rx: <span class="type">Option</span>&lt;Arc&lt;Mutex&lt;Receiver&lt;<span class="type">String</span>&gt;&gt;&gt;&gt;,</span><br><span class="line">tx: <span class="type">Option</span>&lt;Arc&lt;Mutex&lt;Sender&lt;<span class="type">String</span>&gt;&gt;&gt;&gt;,</span><br></pre></td></tr></table></figure>
<p>Now you probably see errors like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0599]: no method named `recv` found for type `std::sync::Arc&lt;std::sync::Mutex&lt;std::sync::mpsc::Receiver&lt;std::string::String&gt;&gt;&gt;` in the current scope</span><br><span class="line">  --&gt; src/cluster/client.rs:66:28</span><br><span class="line">   |</span><br><span class="line">66 |                 match chan.recv() &#123;</span><br><span class="line">   |                            ^^^^</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0599`.</span><br><span class="line">error: Could not compile `iridium`.</span><br><span class="line">warning: build failed, waiting for other jobs to finish...</span><br><span class="line">error[E0599]: no method named `recv` found for type `std::sync::Arc&lt;std::sync::Mutex&lt;std::sync::mpsc::Receiver&lt;std::string::String&gt;&gt;&gt;` in the current scope</span><br><span class="line">  --&gt; src/cluster/client.rs:66:28</span><br><span class="line">   |</span><br><span class="line">66 |                 match chan.recv() &#123;</span><br><span class="line">   |                            ^^^^</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>
<p>If you replace Mutex with RwLock, you’ll note that it doesn’t work.
Why not? Well, I will steal from the Rust docs:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</span><br><span class="line"></span><br><span class="line">In comparison, a Mutex does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An RwLock will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</span><br><span class="line"></span><br><span class="line">The priority policy of the lock is dependent on the underlying operating system&#x27;s implementation, and this type does not guarantee that any particular policy will be used.</span><br><span class="line"></span><br><span class="line">The type parameter T represents the data that this lock protects. It is required that T satisfies Send to be shared across threads and Sync to allow concurrent access through readers. The RAII guards returned from the locking methods implement Deref (and DerefMut for the write methods) to allow access to the content of the lock.</span><br></pre></td></tr></table></figure>
<p>The last paragraph is key: T (in this case, our channels) only have
the Send attribute. Using a Mutex gives them <code>Sync</code>, which
let’s them move across threads.</p>
<h3 id="resolving-recv-issue">Resolving recv() Issue</h3>
<p>Now let’s see if we can resolve that issue. In
<code>src/cluster/client.rs</code>, we can replace the
<code>recv_loop()</code> function with:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">recv_loop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">chan</span> = <span class="keyword">self</span>.rx.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">writer</span> = <span class="keyword">self</span>.raw_stream.<span class="title function_ invoke__">try_clone</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(locked_rx) = chan.<span class="title function_ invoke__">lock</span>() &#123;</span><br><span class="line">                <span class="keyword">match</span> locked_rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(msg) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">match</span> writer.<span class="title function_ invoke__">write_all</span>(msg.<span class="title function_ invoke__">as_bytes</span>()) &#123;</span><br><span class="line">                            <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                            <span class="title function_ invoke__">Err</span>(_e) =&gt; &#123;&#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">match</span> writer.<span class="title function_ invoke__">flush</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                            <span class="title function_ invoke__">Err</span>(_e) =&gt; &#123;&#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(_e) =&gt; &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since we now have a Mutex around the chan, we need to lock it in
order to call recv on it. Since this client is the only one using this
particular <code>rx</code> end, this is fine.</p>
<h2 id="compiles">Compiles?!</h2>
<p>Finally! It compiles! We still don’t quite have it where we want to,
though.</p>
<h3 id="accepting-a-new-clusterclient">Accepting a new
ClusterClient</h3>
<p>Right now, we listen for connections in
<code>src/cluster/server.rs</code>, in the <code>listen</code>
function:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">listen</span>(addr: SocketAddr) &#123;</span><br><span class="line">    info!(<span class="string">&quot;Initializing Cluster server...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(addr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        info!(<span class="string">&quot;New Node connected!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = ClusterClient::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">            client.<span class="title function_ invoke__">run</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See how we don’t have the VM anywhere in there? Or the Manager? So we
can’t add it there. Let’s try passing in the Manager. In
<code>src/vm.rs</code>, in <code>bind_cluster_server</code>, we have
this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bind_cluster_server</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> addr) = <span class="keyword">self</span>.server_addr &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> port) = <span class="keyword">self</span>.server_port &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">socket_addr</span>: SocketAddr = (addr.<span class="title function_ invoke__">to_string</span>() + <span class="string">&quot;:&quot;</span> + port).<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">                cluster::server::<span class="title function_ invoke__">listen</span>(socket_addr);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error!(<span class="string">&quot;Unable to bind to cluster server address: &#123;&#125;&quot;</span>, addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error!(<span class="string">&quot;Unable to bind to cluster server port: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.server_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s change it to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bind_cluster_server</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> addr) = <span class="keyword">self</span>.server_addr &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> port) = <span class="keyword">self</span>.server_port &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">socket_addr</span>: SocketAddr = (addr.<span class="title function_ invoke__">to_string</span>() + <span class="string">&quot;:&quot;</span> + port).<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="comment">// Note that we have to make a clone here before we move it into the thread</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">clone</span> = <span class="keyword">self</span>.connection_manager.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">                <span class="comment">// Otherwise, we&#x27;d be trying to move the whole thing out of the VM, not an Arc</span></span><br><span class="line">                cluster::server::<span class="title function_ invoke__">listen</span>(socket_addr, clone);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error!(<span class="string">&quot;Unable to bind to cluster server address: &#123;&#125;&quot;</span>, addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error!(<span class="string">&quot;Unable to bind to cluster server port: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.server_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Of course, we then need to change the signature of the listen
function in <code>src/cluster/server.rs</code> to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">listen</span>(addr: SocketAddr, connection_manager: Arc&lt;RwLock&lt;Manager&gt;&gt;) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>And don’t forget to add:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> cluster::manager::Manager;</span><br></pre></td></tr></table></figure>
<p>If you run <code>cargo test</code>, it should compile now. Yay!</p>
<h3 id="adding-the-clusterclient-to-the-manager">Adding the
ClusterClient to the Manager</h3>
<p>Now if we head over to <code>src/cluster/server.rs</code>, we now
have a <code>Arc&lt;Mutex&lt;Manager&gt;&gt;</code> we can use to add
the client.</p>
<p>Except…​</p>
<p>Because they just connected, we don’t know their alias yet.</p>
<h3 id="who.are-you">Who…​.are you?</h3>
<p>Because our HashMap uses the node alias as the key, we need SOMETHING
to put there. There’s two obvious options:</p>
<ol type="1">
<li>We have the ClusterClient send its alias first</li>
<li>We generate a random UUID for the alias, until the client sends us
its proper one</li>
</ol>
<p>In <code>server.rs</code>, note this line:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>
<p>We COULD do something like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = ClusterClient::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">    <span class="comment">// Once this call succeeds, we&#x27;ll hopefully have the node alias in the string buffer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes_read</span> = client.<span class="title function_ invoke__">read</span>(&amp;buf);</span><br><span class="line">    client.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Of course, this means we need to write the node alias…​so head over
<code>src/repl/mod.rs</code>. The join_cluster function for
<code>ClusterClient</code> looks like:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">join_cluster</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: &amp;[&amp;<span class="type">str</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Attempting to join cluster...&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">port</span> = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = ip.<span class="title function_ invoke__">to_owned</span>() + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(stream) = TcpStream::<span class="title function_ invoke__">connect</span>(addr) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Connected to cluster!&quot;</span>));</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cc</span> = cluster::client::ClusterClient::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> a) = <span class="keyword">self</span>.vm.alias &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(<span class="keyword">mut</span> lock) = <span class="keyword">self</span>.vm.connection_manager.<span class="title function_ invoke__">write</span>() &#123;</span><br><span class="line">                lock.<span class="title function_ invoke__">add_client</span>(a.<span class="title function_ invoke__">to_string</span>(), cc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Could not connect to cluster!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s try adding a call to <code>send_hello</code> (defined in the
ClusterClient), like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">join_cluster</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: &amp;[&amp;<span class="type">str</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Attempting to join cluster...&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip</span> = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">port</span> = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = ip.<span class="title function_ invoke__">to_owned</span>() + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(stream) = TcpStream::<span class="title function_ invoke__">connect</span>(addr) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Connected to cluster!&quot;</span>));</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cc</span> = cluster::client::ClusterClient::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">        cc.<span class="title function_ invoke__">send_hello</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> a) = <span class="keyword">self</span>.vm.alias &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(<span class="keyword">mut</span> lock) = <span class="keyword">self</span>.vm.connection_manager.<span class="title function_ invoke__">write</span>() &#123;</span><br><span class="line">                lock.<span class="title function_ invoke__">add_client</span>(a.<span class="title function_ invoke__">to_string</span>(), cc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_message</span>(<span class="built_in">format!</span>(<span class="string">&quot;Could not connect to cluster!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And naturally, the compiler wants us to change the
<code>listen</code> function in <code>src/cluster/server</code> to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">listen</span>(addr: SocketAddr, connection_manager: Arc&lt;RwLock&lt;Manager&gt;&gt;) &#123;</span><br><span class="line">    info!(<span class="string">&quot;Initializing Cluster server...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(addr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        info!(<span class="string">&quot;New Node connected!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = ClusterClient::<span class="title function_ invoke__">new</span>(stream);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">bytes_read</span> = client.reader.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">alias</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;buf);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Alias is: &#123;:?&#125;&quot;</span>, alias);</span><br><span class="line">            client.<span class="title function_ invoke__">run</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The change is the pre-allocated slice of 1024 bytes into which data
is read. With all that, the tests should pass!</p>
<h3 id="connection-test">Connection Test</h3>
<p>Do the start two VMs, <code>!start_cluster</code> on one,
<code>!join_cluster</code> on the other, and you’ll probably see
something like:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Started cluster server!</span><br><span class="line">&gt;&gt;&gt; Alias is: <span class="string">&quot;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u&#123;0&#125;\u</span></span><br></pre></td></tr></table></figure>
<h2 id="end">End</h2>
<p>We’ll get into why next tutorial. =) We’re getting there!</p>
<p>refer to <a
target="_blank" rel="noopener" href="https://blog.subnetzero.io/post/building-language-vm-part-29/">building-language-vm</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://animenzzzzzz.github.io">Animenzzzzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://animenzzzzzz.github.io/pages/build-your-own-vm/29/">https://animenzzzzzz.github.io/pages/build-your-own-vm/29/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://animenzzzzzz.github.io" target="_blank">My Dearest</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/virtual-machine/">virtual-machine</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/pages/build-your-own-vm/28/" title="Clustering - Part 2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Clustering - Part 2</div></div></a><a class="next-post pull-right" href="/pages/build-your-own-vm/30/" title="Cleanup Time"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Cleanup Time</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/pages/build-your-own-vm/00/" title="Computer Hardware Crash Course"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="title">Computer Hardware Crash Course</div></div></a><a href="/pages/build-your-own-vm/01/" title="Overview and a Simple VM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">Overview and a Simple VM</div></div></a><a href="/pages/build-your-own-vm/03/" title="More Basic Opcodes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">More Basic Opcodes</div></div></a><a href="/pages/build-your-own-vm/02/" title="Basic Opcodes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">Basic Opcodes</div></div></a><a href="/pages/build-your-own-vm/04/" title="Jumps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="title">Jumps</div></div></a><a href="/pages/build-your-own-vm/05/" title="Equality Checks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="title">Equality Checks</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Animenzzzzzz</div><div class="author-info-description">向来如此，便对么？</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Animenzzzzzz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Animenzzzzzz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jinnianqianyin@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">嘿咻~嘿咻~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#intro"><span class="toc-number">1.</span> <span class="toc-text">Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mpsc-channels"><span class="toc-number">1.1.</span> <span class="toc-text">mpsc Channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#simple-usage-example"><span class="toc-number">1.2.</span> <span class="toc-text">Simple Usage Example</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-multi-part"><span class="toc-number">2.</span> <span class="toc-text">The Multi Part</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#our-problem"><span class="toc-number">3.</span> <span class="toc-text">Our Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#the-manager"><span class="toc-number">3.1.</span> <span class="toc-text">The Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolving-recv-issue"><span class="toc-number">3.2.</span> <span class="toc-text">Resolving recv() Issue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compiles"><span class="toc-number">4.</span> <span class="toc-text">Compiles?!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#accepting-a-new-clusterclient"><span class="toc-number">4.1.</span> <span class="toc-text">Accepting a new
ClusterClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adding-the-clusterclient-to-the-manager"><span class="toc-number">4.2.</span> <span class="toc-text">Adding the
ClusterClient to the Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#who.are-you"><span class="toc-number">4.3.</span> <span class="toc-text">Who…​.are you?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connection-test"><span class="toc-number">4.4.</span> <span class="toc-text">Connection Test</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#end"><span class="toc-number">5.</span> <span class="toc-text">End</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Animenzzzzzz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({svg}) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>