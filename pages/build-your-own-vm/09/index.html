<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Assembler-Cruise Control | My Dearest</title><meta name="author" content="Animenzzzzzz"><meta name="copyright" content="Animenzzzzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Megazord…​ACTIVATE!!! We’ve written basic parsers. Now we can take a step up on the abstraction ladder and create a parser that combines some of our smaller parsers. Right now, we can recognize one">
<meta property="og:type" content="article">
<meta property="og:title" content="Assembler-Cruise Control">
<meta property="og:url" content="https://animenzzzzzz.github.io/pages/build-your-own-vm/09/index.html">
<meta property="og:site_name" content="My Dearest">
<meta property="og:description" content="Megazord…​ACTIVATE!!! We’ve written basic parsers. Now we can take a step up on the abstraction ladder and create a parser that combines some of our smaller parsers. Right now, we can recognize one">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://animenzzzzzz.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-12-24T08:13:04.000Z">
<meta property="article:modified_time" content="2025-01-03T07:34:46.412Z">
<meta property="article:author" content="Animenzzzzzz">
<meta property="article:tag" content="virtual-machine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://animenzzzzzz.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://animenzzzzzz.github.io/pages/build-your-own-vm/09/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Assembler-Cruise Control',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 15:34:46'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a href="/" title="My Dearest"><span class="site-name">My Dearest</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Assembler-Cruise Control</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-24T08:13:04.000Z" title="发表于 2024-12-24 16:13:04">2024-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-03T07:34:46.412Z" title="更新于 2025-01-03 15:34:46">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer/">Computer</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer/Virtual-Machine/">Virtual Machine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Assembler-Cruise Control"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="megazordactivate">Megazord…​ACTIVATE!!!</h2>
<p>We’ve written basic parsers. Now we can take a step up on the
abstraction ladder and create a parser that combines some of our smaller
parsers. Right now, we can recognize one opcode, registers and integer
operands. We can group these into an <code>AssemblerInstruction</code>.
In <code>src/assembler/instruction_parsers.rs</code>, put:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> assembler::Token;</span><br><span class="line"><span class="keyword">use</span> assembler::opcode_parsers::*;</span><br><span class="line"><span class="keyword">use</span> assembler::operand_parsers::integer_operand;</span><br><span class="line"><span class="keyword">use</span> assembler::register_parsers::register;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AssemblerInstruction</span> &#123;</span><br><span class="line">    opcode: Token,</span><br><span class="line">    operand1: <span class="type">Option</span>&lt;Token&gt;,</span><br><span class="line">    operand2: <span class="type">Option</span>&lt;Token&gt;,</span><br><span class="line">    operand3: <span class="type">Option</span>&lt;Token&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And now, the parser for the instruction itself…​</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handles instructions of the following form:</span></span><br><span class="line"><span class="comment">/// LOAD $0 #100</span></span><br><span class="line">named!(<span class="keyword">pub</span> instruction_one&lt;CompleteStr, AssemblerInstruction&gt;,</span><br><span class="line">    do_parse!(</span><br><span class="line">        o: opcode_load &gt;&gt;</span><br><span class="line">        r: register &gt;&gt;</span><br><span class="line">        i: integer_operand &gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            AssemblerInstruction&#123;</span><br><span class="line">                opcode: o,</span><br><span class="line">                operand1: <span class="title function_ invoke__">Some</span>(r),</span><br><span class="line">                operand2: <span class="title function_ invoke__">Some</span>(i),</span><br><span class="line">                operand3: <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>See how we are using the parsers we defined? <code>opcode</code>,
<code>register</code> and <code>integer</code>. Collectively, they make
up one <code>AssemblerInstruction</code>. We leave the operand fields as
Optional, to allow greater flexibility.</p>
<h2 id="tests">Tests</h2>
<p>Now a test…​put this at the bottom of
<code>src/assembler/instruction_parsers.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> assembler::opcode::Opcode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_parse_instruction_form_one</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">instruction_one</span>(<span class="title function_ invoke__">CompleteStr</span>(<span class="string">&quot;load $0 #100\n&quot;</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            result,</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>((</span><br><span class="line">                <span class="title function_ invoke__">CompleteStr</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">                AssemblerInstruction &#123;</span><br><span class="line">                    opcode: Token::Op &#123; code: Opcode::LOAD &#125;,</span><br><span class="line">                    operand1: <span class="title function_ invoke__">Some</span>(Token::Register &#123; reg_num: <span class="number">0</span> &#125;),</span><br><span class="line">                    operand2: <span class="title function_ invoke__">Some</span>(Token::IntegerOperand &#123; value: <span class="number">100</span> &#125;),</span><br><span class="line">                    operand3: <span class="literal">None</span></span><br><span class="line">                &#125;</span><br><span class="line">            ))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="up-to-program">Up to Program</h2>
<p>And now our final parser, the <code>Program</code> parser. A
<code>Program</code> consists of <code>Instructions</code>. Make
<code>src/assembler/program_parsers.rs</code>, and in it put:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> nom::types::CompleteStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> assembler::instruction_parsers::&#123;AssemblerInstruction, instruction_one&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    instructions: <span class="type">Vec</span>&lt;AssemblerInstruction&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">named!(<span class="keyword">pub</span> program&lt;CompleteStr, Program&gt;,</span><br><span class="line">    do_parse!(</span><br><span class="line">        instructions: many1!(instruction_one) &gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            Program &#123;</span><br><span class="line">                instructions: instructions</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We now have a struct that contains a vector of assembler
instructions. Next step is to give AssemblerInstructions the ability to
write themselves out as <code>Vec&lt;u8&gt;</code>s. Then we just have
to iterate through the <code>instructions</code> vec and done!</p>
<p>But first…​</p>
<h2 id="another-test">ANOTHER TEST!</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_parse_program</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">program</span>(<span class="title function_ invoke__">CompleteStr</span>(<span class="string">&quot;load $0 #100\n&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result.<span class="title function_ invoke__">is_ok</span>(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> (leftover, p) = result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(leftover, <span class="title function_ invoke__">CompleteStr</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        p.instructions.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Figure out an ergonomic way to test the AssemblerInstruction returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The instructions field of <code>p</code> (which is a
<code>Program</code> struct) is private. I’m not sure if it is better to
make them public, make an accessor function, or what. Let’s revisit this
later.</p>
<h2 id="getting-at-the-bits">Getting at the Bits</h2>
<p>We need each <code>AssemblerInstruction</code> to have a function we
can call to get a <code>Vec&lt;u8&gt;</code>. Let’s head over to
<code>instruction_parser.rs</code> and add one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">AssemblerInstruction</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">to_bytes</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.opcode &#123;</span><br><span class="line">            Token::Op &#123; code &#125; =&gt; <span class="keyword">match</span> code &#123;</span><br><span class="line">                _ =&gt; &#123;</span><br><span class="line">                    results.<span class="title function_ invoke__">push</span>(code <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Non-opcode found in opcode field&quot;</span>);</span><br><span class="line">                std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">operand</span> <span class="keyword">in</span> <span class="built_in">vec!</span>[&amp;<span class="keyword">self</span>.operand1, &amp;<span class="keyword">self</span>.operand2, &amp;<span class="keyword">self</span>.operand3] &#123;</span><br><span class="line">            <span class="keyword">match</span> operand &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(t) =&gt; AssemblerInstruction::<span class="title function_ invoke__">extract_operand</span>(t, &amp;<span class="keyword">mut</span> results),</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is where implementing
<code>impl From&lt;u8&gt; for Opcode &#123;</code> over in
<code>src/instruction.rs</code> pays off. If you derive
<code>Copy</code> and <code>Clone</code> on the <code>Opcode</code>
enum, then we can convert any opcode into its integer with
<code>code as u8</code>. All this function does is write the opcode bit
to a vector, then uses a helper function to extract the operands for any
of the operand fields that are not None.</p>
<p>That helper function also goes in
<code>impl AssemblerInstruction</code> and looks like:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">extract_operand</span>(t: &amp;Token, results: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> t &#123;</span><br><span class="line">        Token::Register &#123; reg_num &#125; =&gt; &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(*reg_num);</span><br><span class="line">        &#125;</span><br><span class="line">        Token::IntegerOperand &#123; value &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">converted</span> = *value <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte1</span> = converted;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte2</span> = converted &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(byte2 <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(byte1 <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Opcode found in operand field&quot;</span>);</span><br><span class="line">            std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I thought for sure <code>borrowck</code> was going to chastise, but
passing the results vector around worked like I thought it would.</p>
<p>What <code>extract_operand</code> does is check for the operand type,
converts it to bytes and then stuffs them in the results vector.</p>
<p>You may wonder why we order them this way:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results.<span class="title function_ invoke__">push</span>(byte2 <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">results.<span class="title function_ invoke__">push</span>(byte1 <span class="keyword">as</span> <span class="type">u8</span>);</span><br></pre></td></tr></table></figure>
<p>and not:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results.<span class="title function_ invoke__">push</span>(byte1 <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">results.<span class="title function_ invoke__">push</span>(byte2 <span class="keyword">as</span> <span class="type">u8</span>);</span><br></pre></td></tr></table></figure>
<p>This is because they need to be in the proper order according to our
big endian/little endian rule.</p>
<h2 id="back-to-the-program">Back to the Program</h2>
<p>Let’s go back to <code>program_parsers.rs</code> and add a function
to convert the entire vector of <code>AssemblerInstruction</code> to
bytes:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">to_bytes</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">program</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">instruction</span> <span class="keyword">in</span> &amp;<span class="keyword">self</span>.instructions &#123;</span><br><span class="line">            program.<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> instruction.<span class="title function_ invoke__">to_bytes</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        program</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_program_to_bytes</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">program</span>(<span class="title function_ invoke__">CompleteStr</span>(<span class="string">&quot;load $0 #100\n&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result.<span class="title function_ invoke__">is_ok</span>(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> (_, program) = result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytecode</span> = program.<span class="title function_ invoke__">to_bytes</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(bytecode.<span class="title function_ invoke__">len</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bytecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="modifying-the-repl">Modifying the REPL</h2>
<p>Almost done! Right now, our REPL still speaks hex. Head over
<code>src/repl/mod.rs</code> and in the catch-all match arm of the
function run, put:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_ =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_program</span> = <span class="title function_ invoke__">program</span>(<span class="title function_ invoke__">CompleteStr</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> !parsed_program.<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Unable to parse input&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> (_, result) = parsed_program.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytecode</span> = result.<span class="title function_ invoke__">to_bytes</span>();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Make a function to let us add bytes to the VM</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> bytecode &#123;</span><br><span class="line">        <span class="keyword">self</span>.vm.<span class="title function_ invoke__">add_byte</span>(byte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.vm.<span class="title function_ invoke__">run_once</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if you do cargo run and type in <code>load $0 #100</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Iridium! Lets be productive!</span><br><span class="line">&gt;&gt;&gt; load $<span class="number">0</span> #<span class="number">100</span></span><br><span class="line">&gt;&gt;&gt; .registers</span><br><span class="line">Listing registers and all contents:</span><br><span class="line">[</span><br><span class="line">    <span class="number">100</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">]</span><br><span class="line">End of Register Listing</span><br></pre></td></tr></table></figure>
<h2 id="a-wild-bug-appears">A Wild Bug Appears!</h2>
<p>Try entering <code>LOAD $0 #100</code>. You should get:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; LOAD $<span class="number">0</span> #<span class="number">100</span></span><br><span class="line">Unable to parse input</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Our assembler is case-sensitive! I’m going to leave it as an exercise
for the reader to figure out how to fix it.</p>
<h2 id="hex-code">Hex code</h2>
<p>At this point, we could delete the <code>parse_hex</code> function,
or we can leave it in case someone’s idea of a good time on a Friday
night is to code in hex. Some options on what to do with it are:</p>
<ol type="1">
<li>The REPL could try both and go with whichever parser doesn’t return
an <code>Error</code></li>
<li>The REPL could look for input prefaced with <code>0x</code> and use
<code>parse_hex</code> for that input</li>
<li>We could add a command to our REPL to let it switch input modes. In
one, it accepts hex. In the other, assembly code.</li>
</ol>
<h2 id="end">End</h2>
<p>Yay, we now have a basic, but functional, assembler. Next, we’ll
teach our assembler how to recognize more opcodes and instruction forms,
and how to provide helpful hints to the user when they type something
incorrectly. See you then!</p>
<p>refer to <a
target="_blank" rel="noopener" href="https://blog.subnetzero.io/post/building-language-vm-part-09/">building-language-vm</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://animenzzzzzz.github.io">Animenzzzzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://animenzzzzzz.github.io/pages/build-your-own-vm/09/">https://animenzzzzzz.github.io/pages/build-your-own-vm/09/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://animenzzzzzz.github.io" target="_blank">My Dearest</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/virtual-machine/">virtual-machine</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/pages/build-your-own-vm/08/" title="Assembler-The Beginning"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Assembler-The Beginning</div></div></a><a class="next-post pull-right" href="/pages/build-your-own-vm/10/" title="Assembler-Assemble Harder"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Assembler-Assemble Harder</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/pages/build-your-own-vm/00/" title="Computer Hardware Crash Course"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="title">Computer Hardware Crash Course</div></div></a><a href="/pages/build-your-own-vm/01/" title="Overview and a Simple VM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">Overview and a Simple VM</div></div></a><a href="/pages/build-your-own-vm/03/" title="More Basic Opcodes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">More Basic Opcodes</div></div></a><a href="/pages/build-your-own-vm/02/" title="Basic Opcodes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="title">Basic Opcodes</div></div></a><a href="/pages/build-your-own-vm/04/" title="Jumps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="title">Jumps</div></div></a><a href="/pages/build-your-own-vm/05/" title="Equality Checks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="title">Equality Checks</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Animenzzzzzz</div><div class="author-info-description">向来如此，便对么？</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Animenzzzzzz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Animenzzzzzz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jinnianqianyin@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">嘿咻~嘿咻~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#megazordactivate"><span class="toc-number">1.</span> <span class="toc-text">Megazord…​ACTIVATE!!!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tests"><span class="toc-number">2.</span> <span class="toc-text">Tests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#up-to-program"><span class="toc-number">3.</span> <span class="toc-text">Up to Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#another-test"><span class="toc-number">4.</span> <span class="toc-text">ANOTHER TEST!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getting-at-the-bits"><span class="toc-number">5.</span> <span class="toc-text">Getting at the Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#back-to-the-program"><span class="toc-number">6.</span> <span class="toc-text">Back to the Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modifying-the-repl"><span class="toc-number">7.</span> <span class="toc-text">Modifying the REPL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-wild-bug-appears"><span class="toc-number">8.</span> <span class="toc-text">A Wild Bug Appears!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hex-code"><span class="toc-number">9.</span> <span class="toc-text">Hex code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#end"><span class="toc-number">10.</span> <span class="toc-text">End</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Animenzzzzzz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({svg}) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>