<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>React | My Dearest</title><meta name="author" content="Animenzzzzzz"><meta name="copyright" content="Animenzzzzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 本书的宗旨是打造一本严谨、易懂的React源码分析教程。 理念篇 第一章 React的理念 React 理念 我们可以从官网看到React的理念：  我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。  可见，关键是实现快速响应。那么制约快速响应的因素是什么呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="React">
<meta property="og:url" content="https://animenzzzzzz.github.io/pages/web/React/index.html">
<meta property="og:site_name" content="My Dearest">
<meta property="og:description" content="前言 本书的宗旨是打造一本严谨、易懂的React源码分析教程。 理念篇 第一章 React的理念 React 理念 我们可以从官网看到React的理念：  我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。  可见，关键是实现快速响应。那么制约快速响应的因素是什么呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://animenzzzzzz.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-03-27T05:37:20.000Z">
<meta property="article:modified_time" content="2025-03-31T03:49:51.455Z">
<meta property="article:author" content="Animenzzzzzz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://animenzzzzzz.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://animenzzzzzz.github.io/pages/web/React/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-31 11:49:51'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top_img.jpg);"><nav id="nav"><span id="blog-info"><a href="/" title="My Dearest"><span class="site-name">My Dearest</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">React</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-27T05:37:20.000Z" title="发表于 2025-03-27 13:37:20">2025-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-31T03:49:51.455Z" title="更新于 2025-03-31 11:49:51">2025-03-31</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言">前言</h1>
<p>本书的宗旨是打造一本严谨、易懂的React源码分析教程。</p>
<h1 id="理念篇">理念篇</h1>
<h2 id="第一章-react的理念">第一章 React的理念</h2>
<h3 id="react-理念">React 理念</h3>
<p>我们可以从官网看到React的理念：</p>
<blockquote>
<p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web
应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>
</blockquote>
<p>可见，关键是实现<code>快速响应</code>。那么制约<code>快速响应</code>的因素是什么呢？</p>
<p>我们日常使用
App，浏览网页时，有两类场景会制约<code>快速响应</code>：</p>
<ul>
<li>当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</li>
<li>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li>
</ul>
<p>这两类场景可以概括为：</p>
<ul>
<li>CPU 的瓶颈</li>
<li>IO 的瓶颈</li>
</ul>
<p><code>React</code>是如何解决这两个瓶颈的呢？</p>
<h4 id="cpu-的瓶颈">CPU 的瓶颈</h4>
<p>当项目变得庞大、组件数量繁多时，就容易遇到 CPU 的瓶颈。</p>
<p>考虑如下 Demo，我们向视图中渲染 3000 个li：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="number">3000</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;Array(len)</span></span><br><span class="line"><span class="language-xml">        .fill(0)</span></span><br><span class="line"><span class="language-xml">        .map((_, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootEl);</span><br></pre></td></tr></table></figure>
<p>主流浏览器刷新频率为 60Hz，即每（1000ms / 60Hz）16.6ms
浏览器刷新一次。</p>
<p>我们知道，JS 可以操作
DOM，<code>GUI渲染线程</code>与<code>JS线程</code>是互斥的。所以<strong>JS
脚本执行和浏览器布局、绘制</strong>不能同时执行。</p>
<p>在每 16.6ms 时间内，需要完成如下工作：</p>
<blockquote>
<p>JS脚本执行 ----- 样式布局 ----- 样式绘制</p>
</blockquote>
<p>当 JS 执行时间过长，超出了
16.6ms，这次刷新就没有时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>了。</p>
<p>在 Demo 中，由于组件数量繁多（3000 个），JS
脚本执行时间过长，页面掉帧，造成卡顿。</p>
<p>可以从打印的执行堆栈图看到，JS 执行时间为
73.65ms，远远多于一帧的时间。</p>
<figure>
<img src="/img/web/react-01.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
堆栈图
</figcaption>
</figure>
<p>如何解决这个问题呢？</p>
<p>答案是：在浏览器每一帧的时间中，预留一些时间给 JS
线程，React利用这部分时间更新组件（可以看到，在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119">源码</a>中，预留的初始时间是
5ms）。</p>
<p>当预留的时间不够用时，React将线程控制权交还给浏览器使其有时间渲染
UI，React则等待下一帧时间到来继续被中断的工作。</p>
<blockquote>
<p>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为<code>时间切片</code>（time
slice）</p>
</blockquote>
<p>接下来我们开启<code>Concurrent Mode</code>（后续章节会讲到，当前你只需了解开启后会启用<code>时间切片</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode</span></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;App/&gt;, rootEl);</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">unstable_createRoot</span>(rootEl).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>此时我们的长任务被拆分到每一帧不同的task中，JS脚本执行时间大体在5ms左右，这样浏览器就有剩余时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>，减少掉帧的可能性。</p>
<figure>
<img src="/img/web/react-02.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
堆栈图
</figcaption>
</figure>
<p>所以，解决<code>CPU瓶颈</code>的关键是实现<code>时间切片</code>，而<code>时间切片</code>的关键是：将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<h4 id="io-的瓶颈">IO 的瓶颈</h4>
<p><code>网络延迟</code>是前端开发者无法解决的。如何在网络延迟客观存在的情况下，减少用户对网络延迟的感知？</p>
<blockquote>
<p>React给出的答案是<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production">将人机交互研究的结果整合到真实的
UI 中</a>。</p>
</blockquote>
<p>这里我们以业界人机交互最顶尖的苹果举例，在 IOS 系统中：</p>
<p>点击“设置”面板中的“通用”，进入“通用”界面：</p>
<figure>
<img src="/img/web/react-01.gif" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
通用界面图
</figcaption>
</figure>
<p>作为对比，再点击“设置”面板中的“Siri 与搜索”，进入“Siri
与搜索”界面：</p>
<figure>
<img src="/img/web/react-02.gif" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
通用界面图
</figcaption>
</figure>
<p>你能感受到两者体验上的区别么？</p>
<p>事实上，点击“通用”后的交互是同步的，直接显示后续界面。而点击“Siri
与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面。但从用户感知来看，这两者的区别微乎其微。</p>
<p>这里的窍门在于：点击“Siri
与搜索”后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。</p>
<p>当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示<code>loading</code>的效果。</p>
<p>试想如果我们一点击“Siri
与搜索”就显示<code>loading</code>效果，即使数据请求时间很短，<code>loading</code>效果一闪而过。用户也是可以感知到的。</p>
<p>为此，React实现了<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html">Suspense</a>功能及配套的hook——<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue">useDeferredValue</a>。</p>
<p>而在源码内部，为了支持这些特性，同样需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<h4 id="总结">总结</h4>
<p>通过以上内容，我们可以看到，<code>React</code>为了践行“构建<strong>快速响应</strong>的大型
Web 应用程序”理念做出的努力。</p>
<p>其中的关键是解决 CPU 的瓶颈与 IO
的瓶颈。而落实到实现上，则需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
<h4 id="参考资料">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV134411c7Sk?from=search&amp;seid=17404881291635824595">「英文」尤雨溪论
JavaScript 框架设计哲学：平衡</a></p>
<h3 id="老的react架构">老的React架构</h3>
<p>在上一节中我们了解了React的理念，简单概括就是<strong>快速响应</strong>。</p>
<p>React从 v15 升级到 v16 后重构了整个架构。本节我们聊聊
v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。</p>
<h4 id="react15-架构">React15 架构</h4>
<p>React15 架构可以分为两层：</p>
<ul>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h5 id="reconciler协调器">Reconciler（协调器）</h5>
<p>我们知道，在React中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等
API 触发更新。</p>
<p>每当有更新发生时，Reconciler会做如下工作：</p>
<ul>
<li>调用函数组件、或 class 组件的<code>render</code>方法，将返回的 JSX
转化为虚拟 DOM</li>
<li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li>
<li>通过对比找出本次更新中变化的虚拟 DOM</li>
<li>通知Renderer将变化的虚拟 DOM 渲染到页面上</li>
</ul>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers">这里</a>看到React官方对Reconciler的解释</p>
</blockquote>
<h5 id="renderer渲染器">Renderer（渲染器）</h5>
<p>由于<code>React</code>支持跨平台，所以不同平台有不同的Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer
—— <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-dom">ReactDOM</a>。</p>
<p>除此之外，还有：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-native">ReactNative</a>渲染器，渲染
App 原生组件</li>
<li><a
target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-test-renderer">ReactTest</a>渲染器，渲染出纯
Js 对象用于测试</li>
<li><a
target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-art">ReactArt</a>渲染器，渲染到
Canvas, SVG 或 VML (IE8)</li>
</ul>
<p>在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers">这里</a>看到React官方对Renderer的解释</p>
</blockquote>
<h4 id="react15-架构的缺点">React15 架构的缺点</h4>
<p>在Reconciler中，mount的组件会调用<code>mountComponent</code>，update的组件会调用<code>updateComponent</code>。这两个方法都会递归更新子组件。</p>
<h5 id="递归更新的缺点">递归更新的缺点</h5>
<p>由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了
16ms，用户交互就会卡顿。</p>
<p>在上一节中，我们已经提出了解决办法——用<strong>可中断的异步更新</strong>代替<strong>同步的更新</strong>。那么
React15 的架构支持异步更新么？让我们看一个<a
target="_blank" rel="noopener" href="https://codesandbox.io/s/fervent-sutherland-pf7sg?file=/src/App.js">例子</a></p>
<figure>
<img src="/img/web/react-03.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
-
</figcaption>
</figure>
<p>我们可以看到，Reconciler和Renderer是交替工作的，当第一个li在页面上已经变化后，第二个li再进入Reconciler。</p>
<p>由于整个过程都是同步的，所以在用户看来所有 DOM 是同时更新的。</p>
<p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p>
<blockquote>
<p>注意：以下是我们模拟中断的情况，实际上React15并不会中断进行中的更新</p>
</blockquote>
<figure>
<img src="/img/web/react-04.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
-
</figcaption>
</figure>
<p>当第一个li完成更新时中断更新，即步骤 3
完成后中断更新，此时后面的步骤都还未执行。</p>
<p>用户本来期望123变为246。实际却看见更新不完全的 DOM！（即223）</p>
<p>基于这个原因，React决定重写整个架构。</p>
<h3 id="新的react架构">新的React架构</h3>
<p>上一节我们聊到 React15
架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的 React16
是如何支持异步更新的。</p>
<h4 id="react16-架构">React16 架构</h4>
<p>React16 架构可以分为三层：</p>
<ul>
<li>Scheduler（调度器）——
调度任务的优先级，高优任务优先进入Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>可以看到，相较于 React15，React16
中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p>
<h5 id="scheduler调度器">Scheduler（调度器）</h5>
<p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>
<p>其实部分浏览器已经实现了这个 API，这就是<a
target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">requestIdleCallback</a>。但是由于以下因素，React放弃使用：</p>
<ul>
<li>浏览器兼容性</li>
<li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前
tab 注册的<code>requestIdleCallback</code>触发的频率会变得很低</li>
</ul>
<p>基于以上原因，React实现了功能更完备的<code>requestIdleCallback</code>
polyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md">Scheduler</a>是独立于React的库</p>
</blockquote>
<h5 id="reconciler协调器-1">Reconciler（协调器）</h5>
<p>我们知道，在 React15 中Reconciler是递归处理虚拟 DOM 的。让我们看看<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673">React16
的 Reconciler</a>。</p>
<p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@noinline</span> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>在 React16
中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟
DOM 打上代表增/删/更新的标记，类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PlacementAndUpdate</span> = <span class="comment">/*    */</span> <span class="number">0b0000000000110</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>全部的标记见<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js">这里</a></p>
</blockquote>
<h5 id="renderer渲染器-1">Renderer（渲染器）</h5>
<p>Renderer根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM
操作。</p>
<p>所以，对于我们在上一节使用过的 Demo 在 React16
架构中整个更新流程为：</p>
<figure>
<img src="/img/web/react-05.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
-
</figcaption>
</figure>
<p>其中红框中的步骤随时可能由于以下原因被中断：</p>
<ul>
<li>有其他更高优任务需要先更新</li>
<li>当前帧没有剩余时间</li>
</ul>
<p>由于红框中的工作都在内存中进行，不会更新页面上的
DOM，所以即使反复中断，用户也不会看见更新不完全的
DOM（即上一节演示的情况）。</p>
<blockquote>
<p>实际上，由于Scheduler和Reconciler都是平台无关的，所以React为他们单独发了一个包<a
target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-reconciler">react-Reconciler</a>。你可以用这个包自己实现一个ReactDOM，具体见<strong>参考资料</strong></p>
</blockquote>
<h4 id="总结-1">总结</h4>
<p>通过本节我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p>
<p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p>
<p><code>Fiber</code>是什么？他和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来三节解答。</p>
<h4 id="参考资料-1">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CGpMlWVcHok&amp;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&amp;index=7">「英文
外网」Building a Custom React Renderer | React 前经理 Sophie
Alpert</a></p>
<p><a
target="_blank" rel="noopener" href="https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc">hello-world-custom-react-renderer</a></p>
<blockquote>
<p>同步/Debounce/Throttle/并发 情况下性能对比 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/concurrent-3h48s?file=/src/index.js">Demo</a></p>
</blockquote>
<h3 id="fiber架构的心智模型">Fiber架构的心智模型</h3>
<p>React核心团队成员Sebastian
Markbåge（<code>React Hooks</code>的发明者）曾说：我们在<code>React</code>中做的就是践行<code>代数效应</code>（Algebraic
Effects）。</p>
<p>那么，<code>代数效应</code>是什么呢？他和<code>React</code>有什么关系呢。</p>
<h4 id="什么是代数效应">什么是代数效应</h4>
<p><code>代数效</code>应是<code>函数式编程</code>中的一个概念，用于将<code>副作用</code>从<code>函数</code>调用中分离。</p>
<p>接下来我们用<code>虚构的语法</code>来解释。</p>
<p>假设我们有一个函数<code>getTotalPicNum</code>，传入2个<code>用户名称</code>后，分别查找该用户在平台保存的图片数量，最后将图片数量相加后返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>getTotalPicNum</code>中，我们不关注<code>getPicNum</code>的实现，只在乎“获取到两个数字后将他们相加的结果返回”这一过程。</p>
<p>接下来我们来实现<code>getPicNum</code>。</p>
<p>"用户在平台保存的图片数量"是保存在服务器中的。所以，为了获取该值，我们需要发起异步请求。</p>
<p>为了尽量保持<code>getTotalPicNum</code>的调用方式不变，我们首先想到了使用<code>async await</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTotalPicNum</span>(<span class="params">user1, user2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum1 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user1);</span><br><span class="line">  <span class="keyword">const</span> picNum2 = <span class="keyword">await</span> <span class="title function_">getPicNum</span>(user2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> picNum1 + picNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>async await</code>是有<code>传染性</code>的 ——
当一个函数变为<code>async</code>后，这意味着调用他的函数也需要是<code>async</code>，这破坏了<code>getTotalPicNum</code>的同步特性。</p>
<p>有没有什么办法能保持<code>getTotalPicNum</code>保持现有调用方式不变的情况下实现异步请求呢？</p>
<p>没有。不过我们可以<code>虚构</code>一个。</p>
<p>我们虚构一个类似<code>try...catch</code>的语法 ——
<code>try...handle</code>与两个操作符<code>perform</code>、<code>resume</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPicNum</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> picNum = perform name;</span><br><span class="line">  <span class="keyword">return</span> picNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">getTotalPicNum</span>(<span class="string">&#x27;kaSong&#x27;</span>, <span class="string">&#x27;xiaoMing&#x27;</span>);</span><br><span class="line">&#125; <span class="title function_">handle</span> (who) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (who) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;kaSong&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">230</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;xiaoMing&#x27;</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">122</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      resume <span class="keyword">with</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行到<code>getTotalPicNum</code>内部的<code>getPicNum</code>方法时，会执行<code>perform name</code>。</p>
<p>此时函数调用栈会从<code>getPicNum</code>方法内跳出，被最近一个<code>try...handle</code>捕获。类似<code>throw Error</code>后被最近一个<code>try...catch</code>捕获。</p>
<p>类似<code>throw Error</code>后<code>Error</code>会作为<code>catch</code>的参数，<code>perform name</code>后<code>name</code>会作为<code>handle</code>的参数。</p>
<p>与<code>try...catch</code>最大的不同在于：当<code>Error</code>被<code>catch</code>捕获后，之前的调用栈就销毁了。而<code>handle</code>执行<code>resume</code>后会回到之前<code>perform</code>的调用栈。</p>
<p>对于<code>case 'kaSong'</code>，执行完<code>resume with 230</code>;后调用栈会回到<code>getPicNum</code>，此时<code>picNum === 230</code></p>
<blockquote>
<p>注意：再次申明，<code>try...handle</code>的语法是虚构的，只是为了演示<code>代数效应</code>的思想。</p>
</blockquote>
<p>总结一下：<code>代数效应</code>能够将<code>副作用</code>（例子中为<code>请求图片数量</code>）从函数逻辑中分离，使函数关注点保持纯粹。</p>
<p>并且，从例子中可以看出，<code>perform resume</code>不需要区分同步异步。</p>
<h4 id="代数效应在react中的应用">代数效应在React中的应用</h4>
<p>那么<code>代数效应</code>与<code>React</code>有什么关系呢？最明显的例子就是<code>Hooks</code>。</p>
<p>对于类似<code>useState</code>、<code>useReducer</code>、<code>useRef</code>这样的<code>Hook</code>，我们不需要关注<code>FunctionComponent</code>的<code>state</code>在<code>Hook</code>中是如何保存的，<code>React</code>会为我们处理。</p>
<p>我们只需要假设<code>useState</code>返回的是我们想要的<code>state</code>，并编写业务逻辑就行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> updateNum(num =&gt; num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个例子还不够明显，可以看看官方的<a
target="_blank" rel="noopener" href="https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160">Suspense
Demo</a></p>
<p>在<code>Demo</code>中<code>ProfileDetails</code>用于展示<code>用户名称</code>。而<code>用户名称</code>是<code>异步请求</code>的。</p>
<p>但是<code>Demo</code>中完全是<code>同步</code>的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProfileDetails</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.<span class="property">user</span>.<span class="title function_">read</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代数效应与generator">代数效应与Generator</h4>
<p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的<strong>同步更新</strong>的架构变为<strong>异步可中断更新</strong>。</p>
<p><strong>异步可中断更新</strong>可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p>
<p>这就是代数效应中<code>try...handle</code>的作用。</p>
<p>其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。</p>
<p>但是<code>Generator</code>的一些缺陷使<code>React</code>团队放弃了他：</p>
<ul>
<li>类似<code>async</code>，<code>Generator</code>也是<code>传染性</code>的，使用了<code>Generator</code>则上下文的其他函数也需要作出改变。这样心智负担比较重。</li>
<li><code>Generator</code>执行的中间状态是上下文关联的。</li>
</ul>
<p>考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">doWork</span>(<span class="params">A, B, C</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="title function_">doExpensiveWorkA</span>(A);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x + <span class="title function_">doExpensiveWorkB</span>(B);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">var</span> z = y + <span class="title function_">doExpensiveWorkC</span>(C);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。</p>
<p>只考虑“单一优先级任务的中断与继续”情况下<code>Generator</code>可以很好的实现异步可中断更新。</p>
<p>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成<code>doExpensiveWorkA</code>与<code>doExpensiveWorkB</code>计算出<code>x</code>与<code>y</code>。</p>
<p>此时B组件接收到一个<strong>高优更新</strong>，由于<code>Generator</code>执行的<strong>中间状态</strong>是上下文关联的，所以计算<code>y</code>时无法复用之前已经计算出的<code>x</code>，需要重新计算。</p>
<p>如果通过<strong>全局变量</strong>保存之前执行的<strong>中间状态</strong>，又会引入新的复杂度。</p>
<blockquote>
<p>更详细的解释可以参考这个<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/7942#issuecomment-254987818">issue</a></p>
</blockquote>
<p>基于这些原因，<code>React</code>没有采用<code>Generator</code>实现<strong>协调器</strong>。</p>
<h4 id="代数效应与fiber">代数效应与Fiber</h4>
<p><code>Fiber</code>并不是计算机术语中的新名词，他的中文翻译叫做<strong>纤程</strong>，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p>
<p>在很多文章中将<strong>纤程</strong>理解为<strong>协程</strong>的一种实现。在JS中，协程的实现便是<code>Generator</code>。</p>
<p>所以，我们可以将纤程(Fiber)、协程(Generator)理解为<strong>代数效</strong>应思想在JS中的体现。</p>
<p><code>React Fiber</code>可以理解为：</p>
<p>React内部实现的一套状态更新机制。支持任务不同<strong>优先级</strong>，可中断与恢复，并且恢复后可以复用之前的<strong>中间状态</strong>。</p>
<p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p>
<p>下一节，我们具体讲解<code>Fiber</code>架构的实现。</p>
<h3 id="fiber架构的实现原理">Fiber架构的实现原理</h3>
<p>在新的React架构一节中，我们提到的<strong>虚拟DOM</strong>在React中有个正式的称呼——<code>Fiber</code>。在之后的学习中，我们会逐渐用<code>Fiber</code>来取代<strong>React16虚拟DOM</strong>这一称呼。</p>
<p>接下来让我们了解下<code>Fiber</code>因何而来？他的作用是什么？</p>
<h4 id="fiber的起源">Fiber的起源</h4>
<blockquote>
<p>最早的<code>Fiber</code>官方解释来源于<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">2016年React团队成员Acdlite的一篇介绍</a>。</p>
</blockquote>
<p>从上一章的学习我们知道：</p>
<p>在<code>React15</code>及以前，<code>Reconciler</code>采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p>
<p>为了解决这个问题，React16将<strong>递归的无法中断的更新</strong>重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的<code>Fiber</code>架构应运而生。</p>
<h4 id="fiber的含义">Fiber的含义</h4>
<p><code>Fiber</code>包含三层含义：</p>
<ol type="1">
<li>作为架构来说，之前React15的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。React16的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</li>
<li>作为静态的数据结构来说，每个<code>Fiber节点</code>对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</li>
<li>作为动态的工作单元来说，每个<code>Fiber节点</code>保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</li>
</ol>
<h4 id="fiber的结构">Fiber的结构</h4>
<p>你可以从这里看到<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117">Fiber节点的属性定义</a>。虽然属性很多，但我们可以按三层含义将他们分类来看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | string,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 作为静态数据结构的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于连接其他Fiber节点形成Fiber树</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为动态的工作单元的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调度优先级相关</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向该fiber在另一次更新时对应的fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="作为架构来说">作为架构来说</h5>
<p>每个<code>Fiber节点</code>有个对应的<code>React element</code>，多个<code>Fiber节点</code>是如何连接形成树呢？靠如下三个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向父级Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>举个例子，如下的组件结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      i am</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>KaSong<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的<code>Fiber树</code>结构：</p>
<figure>
<img src="/img/web/react-06.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
Fiber树结构
</figcaption>
</figure>
<blockquote>
<p>这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执行完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。</p>
</blockquote>
<h5 id="作为静态的数据结构">作为静态的数据结构</h5>
<p>作为一种静态的数据结构，保存了组件相关的信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber对应组件的类型 Function/Class/Host...</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line"><span class="comment">// key属性</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line"><span class="comment">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Fiber对应的真实DOM节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h5 id="作为动态的工作单元">作为动态的工作单元</h5>
<p>作为动态的工作单元，<code>Fiber</code>中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存本次更新造成的状态改变相关信息</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存本次更新会造成的DOM操作</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如下两个字段保存调度优先级相关的信息，会在讲解<code>Scheduler</code>时介绍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度优先级相关</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在2020年5月，调度优先级策略经历了比较大的重构。以<code>expirationTime</code>属性为代表的优先级模型被<code>lane</code>取代。详见这个<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/18796">PR</a>
如果你的源码中<code>fiber.expirationTime</code>仍存在，请参照<a
target="_blank" rel="noopener" href="https://react.iamkasong.com/preparation/source.html">调试源码</a>章节获取最新代码。</p>
</blockquote>
<h4 id="总结-2">总结</h4>
<p>本节我们了解了<code>Fiber</code>的起源与架构，其中<code>Fiber节点</code>可以构成<code>Fiber树</code>。那么<code>Fiber树</code>和页面呈现的<code>DOM树</code>有什么关系，React又是如何更新DOM的呢？</p>
<p>我们会在下一节讲解。</p>
<h4 id="参考资料-2">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1it411p7v6?from=search&amp;seid=3508901752524570226">Lin
Clark - A Cartoon Intro to Fiber - React Conf 2017</a></p>
<h3 id="fiber架构的工作原理">Fiber架构的工作原理</h3>
<p>通过上一节的学习，我们了解了<code>Fiber</code>是什么，知道<code>Fiber节点</code>可以保存对应的<code>DOM节点</code>。</p>
<p>相应的，<code>Fiber节点</code>构成的<code>Fiber树</code>就对应<code>DOM树</code>。</p>
<p>那么如何更新<code>DOM</code>呢？这需要用到被称为“双缓存”的技术。</p>
<h4 id="什么是双缓存">什么是“双缓存”</h4>
<p>当我们用<code>canvas</code>绘制动画，每一帧绘制前都会调用<code>ctx.clearRect</code>清除上一帧的画面。</p>
<p>如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p>
<p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p>
<p>这种<strong>在内存中构建并直接替换</strong>的技术叫做<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2">双缓存</a>。</p>
<p><code>React</code>使用“双缓存”来完成<code>Fiber树</code>的构建与替换——对应着<code>DOM树</code>的创建与更新。</p>
<h4 id="双缓存-fiber-树">双缓存 Fiber 树</h4>
<p>在<code>React</code>中最多会同时存在两棵<code>Fiber树</code>。当前屏幕上显示内容对应的<code>Fiber树</code>称为<code>current Fiber树</code>，正在内存中构建的<code>Fiber树</code>称为<code>workInProgress Fiber树</code>。</p>
<p><code>current Fiber树</code>中的<code>Fiber节点</code>被称为<code>current fiber</code>，<code>workInProgress Fiber树</code>中的<code>Fiber节点</code>被称为<code>workInProgress fiber</code>，他们通过<code>alternate</code>属性连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> === workInProgressFiber;</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> === currentFiber;</span><br></pre></td></tr></table></figure>
<p><code>React</code>应用的根节点通过使<code>current</code>指针在不同<code>Fiber树</code>的<code>rootFiber</code>间切换来完成<code>current Fiber树</code>指向的切换。</p>
<p>即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的<code>current指针</code>指向<code>workInProgress Fiber树</code>，此时<code>workInProgress Fiber树</code>就变为<code>current Fiber树</code>。</p>
<p>每次状态更新都会产生新的<code>workInProgress Fiber树</code>，通过<code>current与workInProgress</code>的替换，完成<code>DOM</code>更新。</p>
<p>接下来我们以具体例子讲解<code>mount时</code>、<code>update时</code>的构建/替换流程。</p>
<h4 id="mount-时">mount 时</h4>
<p>考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, add] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> add(num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>（源码中叫<code>fiberRoot</code>）和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是<code>&lt;App/&gt;</code>所在组件树的根节点。</p>
<p>之所以要区分<code>fiberRootNode</code>与<code>rootFiber</code>，是因为在应用中我们可以多次调用<code>ReactDOM.render</code>渲染不同的组件树，他们会拥有不同的<code>rootFiber</code>。但是整个应用的根节点只有一个，那就是<code>fiberRootNode</code>。</p>
<p><code>fiberRootNode</code>的<code>current</code>会指向当前页面上已渲染内容对应<code>Fiber树</code>，即<code>current Fiber树</code>。</p>
<figure>
<p><img src="/img/web/react-07.png" width="90%" loading="lazy" /></p>
<figcaption style="text-align: center;">
<p>Fiber树结构</p>
</figcaption>
</figure>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRootNode.<span class="property">current</span> = rootFiber;</span><br></pre></td></tr></table></figure></p>
<p>由于是首屏渲染，页面中还没有挂载任何<code>DOM</code>，所以<code>fiberRootNode.current</code>指向的<code>rootFiber</code>没有任何子<code>Fiber节点</code>（即<code>current Fiber树</code>为空）。</p></li>
<li><p>接下来进入<code>render阶段</code>，根据组件返回的<code>JSX</code>在内存中依次创建<code>Fiber节点</code>并连接在一起构建<code>Fiber树</code>，被称为<code>workInProgress Fiber树</code>。（下图中右侧为内存中构建的树，左侧为页面显示的树）</p>
<p>在构建<code>workInProgress Fiber树</code>时会尝试复用<code>current Fiber树</code>中已有的<code>Fiber节点</code>内的属性，在首屏渲染时只有<code>rootFiber</code>存在对应的<code>current fiber</code>（即<code>rootFiber.alternate</code>）。</p>
<figure>
<p><img src="/img/web/react-08.png" width="90%" loading="lazy" /></p>
<figcaption style="text-align: center;">
<p>render阶段</p>
</figcaption>
</figure></li>
<li><p>图中右侧已构建完的<code>workInProgress Fiber树</code>在<code>commit阶段</code>渲染到页面。</p>
<p>此时<code>DOM</code>更新为右侧树对应的样子。<code>fiberRootNode</code>的<code>current指针</code>指向<code>workInProgress Fiber树</code>使其变为<code>current Fiber 树</code>。</p>
<figure>
<p><img src="/img/web/react-09.png" width="90%" loading="lazy" /></p>
<figcaption style="text-align: center;">
<p>commit阶段</p>
</figcaption>
</figure></li>
</ol>
<h4 id="update-时">update 时</h4>
<ol type="1">
<li><p>接下来我们点击<code>p节点</code>触发状态改变，这会开启一次新的<code>render阶段</code>并构建一棵新的<code>workInProgress Fiber 树</code>。</p>
<figure>
<p><img src="/img/web/react-10.png" width="90%" loading="lazy" /></p>
<figcaption style="text-align: center;">
<p>render阶段</p>
</figcaption>
</figure>
<p>和<code>mount</code>时一样，<code>workInProgress fiber</code>的创建可以复用<code>current Fiber树</code>对应的节点数据。</p>
<blockquote>
<p>这个决定是否复用的过程就是 Diff 算法，后面章节会详细讲解</p>
</blockquote></li>
<li><p><code>workInProgress Fiber 树</code>在<code>render阶段</code>完成构建后进入<code>commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>。</p>
<figure>
<p><img src="/img/web/react-11.png" width="90%" loading="lazy" /></p>
<figcaption style="text-align: center;">
<p>commit阶段</p>
</figcaption>
</figure></li>
</ol>
<h4 id="总结-3">总结</h4>
<p>本文介绍了<code>Fiber树</code>的构建与替换过程，这个过程伴随着<code>DOM</code>的更新。</p>
<p>那么在构建过程中每个<code>Fiber节点</code>具体是如何创建的呢？我们会在<code>架构篇</code>的[render
阶段]讲解。</p>
<h4 id="参考资料-3">参考资料</h4>
<p>Fiber 树的创建与切换 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/fiber-switch-4je40">Demo</a></p>
<p>此Demo会在如下时机在控制台打印信息：</p>
<ul>
<li>构建<code>WorkInProgrss Fiber</code>时</li>
<li>在渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>时</li>
</ul>
<h3 id="总结-4">总结</h3>
<p>通过本章的学习，我们了解了<code>React</code>的<code>Scheduler-Reconciler-Renderer</code>架构体系，在结束本章前，我想介绍几个源码内的术语：</p>
<ul>
<li><code>Reconciler</code>工作的阶段被称为<code>render</code>阶段。因为在该阶段会调用组件的<code>render</code>方法。</li>
<li><code>Renderer</code>工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行<code>git commit</code>提交代码。<code>commit阶段</code>会把<code>render阶段</code>提交的信息渲染在页面上。</li>
<li><code>render</code>与<code>commit</code>阶段统称为<code>work</code>，即<code>React</code>在工作中。相对应的，如果任务正在<code>Scheduler</code>内调度，就不属于<code>work</code>。</li>
</ul>
<p>在架构篇我们会分别讲解<code>Reconciler</code>和<code>Renderer</code>的工作流程，所以章节名分别为<code>render阶段</code>和<code>commit阶段</code>。</p>
<h2 id="第二章-前置知识">第二章 前置知识</h2>
<h3 id="源码的文件结构">源码的文件结构</h3>
<p>经过之前的学习，我们已经知道React16的架构分为三层：</p>
<ul>
<li>Scheduler（调度器）——
调度任务的优先级，高优任务优先进入Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>那么架构是如何体现在源码的文件结构上呢，让我们一起看看吧</p>
<h4 id="顶层目录">顶层目录</h4>
<p>除去配置文件和隐藏文件夹，根目录的文件夹包括三个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根目录</span><br><span class="line">├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目</span><br><span class="line">├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）</span><br><span class="line">├── scripts         # 各种工具链的脚本，比如git、jest、eslint等</span><br></pre></td></tr></table></figure>
<p>这里我们关注packages目录</p>
<h4 id="packages目录">packages目录</h4>
<p>目录下的文件夹非常多，我们来看下：</p>
<ul>
<li><p>react文件夹</p>
<p>React的核心，包含所有全局 React API，如：</p>
<ul>
<li>React.createElement</li>
<li>React.Component</li>
<li>React.Children</li>
</ul>
<p>这些 API
是全平台通用的，它不包含<code>ReactDOM</code>、<code>ReactNative</code>等平台特定的代码。在
NPM 上作为<a
target="_blank" rel="noopener" href="https://www.npmjs.com/package/react">单独的一个包</a>发布。</p></li>
<li><p>scheduler文件夹</p>
<p>Scheduler（调度器）的实现。</p></li>
<li><p>shared文件夹 源码中其他模块公用的方法和全局变量，比如在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/shared/ReactSymbols.js">shared/ReactSymbols.js</a>中保存React不同组件类型的定义。
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="variable constant_">REACT_ELEMENT_TYPE</span> = <span class="number">0xeac7</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="variable constant_">REACT_PORTAL_TYPE</span> = <span class="number">0xeaca</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="variable constant_">REACT_FRAGMENT_TYPE</span> = <span class="number">0xeacb</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Renderer相关的文件夹</p>
<p>如下几个文件夹为对应的Renderer <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- react-art</span><br><span class="line">- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口</span><br><span class="line">- react-native-renderer</span><br><span class="line">- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）</span><br><span class="line">- react-test-renderer</span><br></pre></td></tr></table></figure></p></li>
<li><p>试验性包的文件夹</p>
<p>React将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质的，所以不被建议在生产环境使用。包括如下文件夹：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- react-server        # 创建自定义SSR流</span><br><span class="line">- react-client        # 创建自定义的流</span><br><span class="line">- react-fetch         # 用于数据请求</span><br><span class="line">- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型</span><br><span class="line">- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer</span><br></pre></td></tr></table></figure></p></li>
<li><p>辅助包的文件夹</p>
<p>React将一些辅助功能形成单独的包。包括如下文件夹：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- react-is       # 用于测试组件是否是某类型</span><br><span class="line">- react-client   # 创建自定义的流</span><br><span class="line">- react-fetch    # 用于数据请求</span><br><span class="line">- react-refresh  # “热重载”的React官方实现</span><br></pre></td></tr></table></figure></p></li>
<li><p>react-reconciler文件夹</p>
<p>我们需要重点关注<code>react-reconciler</code>，在接下来源码学习中
80%的代码量都来自这个包。</p>
<p>虽然他是一个实验性的包，内部的很多功能在正式版本中还未开放。但是他一边对接Scheduler，一边对接不同平台的Renderer，构成了整个
React16 的架构体系。</p></li>
</ul>
<h3 id="调试源码">调试源码</h3>
<p>了解了源码的文件目录，这一节我们看看如何调试源码。</p>
<p>即使版本号相同（当前最新版为<code>17.0.0 RC</code>），但是<code>facebook/react</code>项目<code>master</code>分支的代码和我们使用<code>create-react-app</code>创建的项目<code>node_modules</code>下的<code>react</code>项目代码还是有些区别。</p>
<p>因为<code>React</code>的新代码都是直接提交到<code>master</code>分支，而<code>create-react-app</code>内的<code>react</code>使用的是稳定版的包。</p>
<p>为了始终使用最新版<code>React</code>教学，我们调试源码遵循以下步骤：</p>
<ol type="1">
<li>从facebook/react项目master分支拉取最新源码</li>
<li>基于最新源码构建react、scheduler、react-dom三个包</li>
<li>通过create-react-app创建测试项目，并使用步骤2创建的包作为项目依赖的包</li>
</ol>
<h4 id="拉取源码">拉取源码</h4>
<p>拉取<code>facebook/react</code>代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/facebook/react.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果拉取速度很慢，可以考虑如下2个方案：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 使用cnpm代理</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com.cnpmjs.org/facebook/react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用码云的镜像（一天会与react同步一次）</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirrors/react.git</span><br></pre></td></tr></table></figure>
<p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切入到react源码所在文件夹</span></span><br><span class="line"><span class="built_in">cd</span> react</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yarn</span><br></pre></td></tr></table></figure>
<p>打包<code>react</code>、<code>scheduler</code>、<code>react-dom</code>三个包为<code>dev</code>环境可以使用的<code>cjs</code>包。</p>
<blockquote>
<p>我们的步骤只包含具体做法，对每一步更详细的介绍可以参考React文档<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/how-to-contribute.html#development-workflow">源码贡献章节</a></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行打包命令</span></span><br><span class="line">yarn build react/index,react/jsx,react-dom/index,scheduler --<span class="built_in">type</span>=NODE</span><br></pre></td></tr></table></figure>
<p>现在源码目录<code>build/node_modules</code>下会生成最新代码的包。我们为<code>react</code>、<code>react-dom</code>创建<code>yarn link</code>。</p>
<blockquote>
<p>通过<code>yarn link</code>可以改变项目中依赖包的目录指向</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/node_modules/react</span><br><span class="line"><span class="comment"># 申明react指向</span></span><br><span class="line">yarn <span class="built_in">link</span></span><br><span class="line"><span class="built_in">cd</span> build/node_modules/react-dom</span><br><span class="line"><span class="comment"># 申明react-dom指向</span></span><br><span class="line">yarn <span class="built_in">link</span></span><br></pre></td></tr></table></figure>
<h4 id="创建项目">创建项目</h4>
<p>接下来我们通过<code>create-react-app</code>在其他地方创建新项目。这里我们随意起名，比如“a-react-demo”。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app a-react-demo</span><br></pre></td></tr></table></figure>
<p>在新项目中，将<code>react</code>与<code>react-dom</code>2个包指向<code>facebook/react</code>下我们刚才生成的包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将项目内的react react-dom指向之前申明的包</span></span><br><span class="line">yarn <span class="built_in">link</span> react react-dom</span><br></pre></td></tr></table></figure>
<p>现在试试在<code>react/build/node_modules/react-dom/cjs/react-dom.development.js</code>中随意打印些东西。</p>
<p>在<code>a-react-demo</code>项目下执行<code>yarn start</code>。现在浏览器控制台已经可以打印出我们输入的东西了。</p>
<p>通过以上方法，我们的运行时代码就和<code>React</code>最新代码一致了。</p>
<h3 id="深入理解jsx">深入理解JSX</h3>
<p><code>JSX</code>作为描述组件内容的数据结构，为 JS
赋予了更多视觉表现力。在<code>React</code>中我们大量使用他。在深入源码之前，有些疑问我们需要先解决：</p>
<ul>
<li><code>JSX</code>和<code>Fiber节点</code>是同一个东西么？</li>
<li><code>React Component</code>、<code>React Element</code>是同一个东西么，他们和JSX有什么关系？</li>
</ul>
<p>带着这些疑问，让我们开始这一节的学习</p>
<h4 id="jsx-简介">JSX 简介</h4>
<p>相信作为<code>React</code>的使用者，你已经接触过<code>JSX</code>。如果你还不了解他，可以看下<a
target="_blank" rel="noopener" href="https://react.docschina.org/docs/introducing-jsx.html">官网对其的描述</a>。</p>
<p><code>JSX</code>在编译时会被<code>Babel</code>编译为<code>React.createElement</code>方法。</p>
<blockquote>
<p>进入 <a target="_blank" rel="noopener" href="https://babeljs.io/repl">demo</a>
尝试在面板左边输入JSX，如：<code>&lt;h3&gt;hello&lt;/h3&gt;</code></p>
</blockquote>
<p>这也是为什么在每个使用JSX的 JS 文件中，你必须显式的声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>否则在运行时该模块内就会报未定义变量 React的错误。</p>
<blockquote>
<p>注意： 在 React17 中，已经不需要显式导入 React 了。详见<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">介绍全新的
JSX 转换</a></p>
</blockquote>
<p><code>JSX</code>并不是只能被编译为<code>React.createElement</code>方法，你可以通过<a
target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx"><span
class="citation"
data-cites="babel/plugin-transform-react-jsx">@babel/plugin-transform-react-jsx</span></a>插件显式告诉<code>Babel</code>编译时需要将<code>JSX</code>编译为什么函数的调用（默认为<code>React.createElement</code>）。</p>
<p>比如在<a
target="_blank" rel="noopener" href="https://github.com/preactjs/preact">preact</a>这个类<code>React</code>库中，<code>JSX</code>会被编译为一个名为<code>h</code>的函数调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;p&gt;<span class="title class_">KaSong</span>&lt;/p&gt;;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="title function_">h</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;KaSong&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="react.createelement">React.createElement</h4>
<p>既然<code>JSX</code>会被编译为<code>React.createElement</code>，让我们看看他做了什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 config 处理后赋值给 props</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 处理 children，会被赋值给props.children</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 defaultProps</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactElement</span>(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span>,</span><br><span class="line">    props</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactElement</span> = <span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 标记这是个 React Element</span></span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">type</span>: type,</span><br><span class="line">    <span class="attr">key</span>: key,</span><br><span class="line">    <span class="attr">ref</span>: ref,</span><br><span class="line">    <span class="attr">props</span>: props,</span><br><span class="line">    <span class="attr">_owner</span>: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>React.createElement</code>最终会调用<code>ReactElement</code>方法返回一个包含组件数据的对象，该对象有个参数<code>$$typeof: REACT_ELEMENT_TYPE</code>标记了该对象是个`React
Element。</p>
<p>所以调用<code>React.createElement</code>返回的对象就是<code>React Element</code>么？</p>
<p><code>React</code>提供了验证合法<code>React Element</code>的全局 API
<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L547">React.isValidElement</a>，我们看下他的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isValidElement</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_ELEMENT_TYPE</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>$$typeof === REACT_ELEMENT_TYPE</code>的非<code>null</code>对象就是一个合法的<code>React Element</code>。换言之，在<code>React</code>中，所有<code>JSX</code>在运行时的返回结果（即<code>React.createElement()</code>的返回值）都是<code>React Element</code>。</p>
<p>那么<code>JSX</code>和<code>React Component</code>的关系呢?</p>
<h4 id="react-component">React Component</h4>
<p>在React中，我们常使用<code>ClassComponent</code>与<code>FunctionComponent</code>构建组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>KaSong<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是ClassComponent：&quot;</span>, <span class="title class_">AppClass</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是Element：&quot;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">AppClass</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AppFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>KaSong<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是FunctionComponent：&quot;</span>, <span class="title class_">AppFunc</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是Element：&quot;</span>, <span class="language-xml"><span class="tag">&lt;<span class="name">AppFunc</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React Component 分类 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/jsx-type-blpuo">Demo</a></p>
</blockquote>
<p>我们可以从 Demo
控制台打印的对象看出，<code>ClassComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppClass</code>自身。</p>
<p><code>FunctionComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppFunc</code>自身，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>),</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">type</span>: ƒ <span class="title class_">AppFunc</span>(),</span><br><span class="line">  <span class="attr">_owner</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">_store</span>: &#123;<span class="attr">validated</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">  <span class="attr">_self</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">_source</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的一点，由于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AppClass</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> === <span class="literal">true</span>;</span><br><span class="line"><span class="title class_">AppFunc</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span> === <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>所以无法通过引用类型区分<code>ClassComponent</code>和<code>FunctionComponent</code>。<code>React</code>通过<code>ClassComponent</code>实例原型上的<code>isReactComponent</code>变量判断是否是<code>ClassComponent</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ClassComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isReactComponent</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="jsx-与-fiber-节点">JSX 与 Fiber 节点</h4>
<p>从上面的内容我们可以发现，JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。</p>
<p>比如如下信息就不包括在JSX中:</p>
<ul>
<li>组件在更新中的<strong>优先级</strong></li>
<li>组件的<code>state</code></li>
<li>组件被打上的用于<code>Renderer</code>的<strong>标记</strong></li>
</ul>
<p>这些内容都包含在<code>Fiber节点</code>中。</p>
<p>所以，在组件<code>mount</code>时，<code>Reconciler</code>根据<code>JSX</code>描述的组件内容生成组件对应的<code>Fiber节点</code>。</p>
<p>在<code>update</code>时，<code>Reconciler</code>将<code>JSX</code>与<code>Fiber节点</code>保存的数据对比，生成组件对应的<code>Fiber节点</code>，并根据对比结果为<code>Fiber节点</code>打上<strong>标记</strong>。</p>
<h4 id="参考资料-4">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ICjOlJL-fUGRb2S_xqBT7Q">如何干掉知乎的全部
DIV --
通过这篇文章在运行时修改React.createElement达到消除页面所有div元素的效果</a></p>
<p><a
target="_blank" rel="noopener" href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">React
官网 Blog，关于 React Component, Element, Instance, Reconciliation
的简介</a></p>
<h1 id="架构篇">架构篇</h1>
<h2 id="第三章-render阶段">第三章 render阶段</h2>
<h3 id="流程概览">流程概览</h3>
<p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p>
<p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p>
<p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p>
<p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p>
<p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599">这里</a>看到workLoopConcurrent的源码</p>
</blockquote>
<p>我们知道<code>Fiber Reconciler</code>是从<code>Stack Reconciler</code>重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：“递”和“归”。</p>
<h4 id="递阶段">“递”阶段</h4>
<p>首先从<code>rootFiber</code>开始向下深度优先遍历。为遍历到的每个<code>Fiber节点</code>调用<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058">beginWork
方法</a>。</p>
<p>该方法会根据传入的<code>Fiber节点</code>创建<code>子Fiber节点</code>，并将这两个<code>Fiber节点</code>连接起来。</p>
<p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>
<h4 id="归阶段">“归”阶段</h4>
<p>在“归”阶段会调用<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652">completeWork</a>处理<code>Fiber节点</code>。</p>
<p>当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。</p>
<p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p>
<p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p>
<h4 id="例子">例子</h4>
<p>以上一节的例子举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      i am</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>KaSong<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>对应的<code>Fiber树</code>结构：</p>
<figure>
<img src="/img/web/react-12.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
commit阶段
</figcaption>
</figure>
<p><code>render阶段</code>会依次执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. rootFiber beginWork</span><br><span class="line">2. App Fiber beginWork</span><br><span class="line">3. div Fiber beginWork</span><br><span class="line">4. &quot;i am&quot; Fiber beginWork</span><br><span class="line">5. &quot;i am&quot; Fiber completeWork</span><br><span class="line">6. span Fiber beginWork</span><br><span class="line">7. span Fiber completeWork</span><br><span class="line">8. div Fiber completeWork</span><br><span class="line">9. App Fiber completeWork</span><br><span class="line">10. rootFiber completeWork</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：之所以没有 “KaSong” Fiber 的
beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p>
</blockquote>
<p>我在beginWork和completeWork调用时打印fiber.tag和fiber.type。</p>
<p>你可以从ReactWorkTags.js看到Fiber节点的所有tag定义。</p>
<p>相信多调试几次，你一定能明白方法的调用顺序<a
target="_blank" rel="noopener" href="https://codesandbox.io/s/beginwork-completework-6pkpn?file=/src/index.js">demo</a></p>
<p>如果将performUnitOfWork转化为递归版本，大体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行beginWork</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行completeWork</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-5">总结</h4>
<p>本节我们介绍了<code>render阶段</code>会调用的方法。在接下来两节中，我们会讲解<code>beginWork</code>和<code>completeWork</code>做的具体工作</p>
<h4 id="参考资料-5">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/">The
how and why on React’s usage of linked list in Fiber to walk the
component’s tree</a></p>
<p><a
target="_blank" rel="noopener" href="https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/">Inside
Fiber: in-depth overview of the new reconciliation algorithm in
React</a></p>
<h3 id="beginwork">beginWork</h3>
<p>上一节我们了解到<code>render阶段</code>的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行<code>beginWork</code>，“归”阶段会执行<code>completeWork</code>。这一节我们看看“递”阶段的<code>beginWork</code>方法究竟做了什么。</p>
<h4 id="方法概览">方法概览</h4>
<p>可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075">源码这里</a>看到<code>beginWork</code>的定义。整个方法大概有
500 行代码。</p>
<p>从上一节我们已经知道，<code>beginWork</code>的工作是传入<code>当前Fiber节点</code>，创建<code>子Fiber节点</code>，我们从传参来看看具体是如何做的。</p>
<h5 id="从传参看方法执行">从传参看方法执行</h5>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>current：当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>workInProgress.alternate</code></li>
<li>workInProgress：当前组件对应的<code>Fiber节点</code></li>
<li>renderLanes：优先级相关，在讲解<code>Scheduler</code>时再讲解</li>
</ul>
<p>从双缓存机制一节我们知道，除<code>rootFiber</code>以外，
组件<code>mount</code>时，由于是首次渲染，是不存在当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>mount</code>时<code>current === null</code>。</p>
<p>组件<code>update</code>时，由于之前已经<code>mount</code>过，所以<code>current !== null</code>。</p>
<p>所以我们可以通过<code>current === null ?</code>来区分组件是处于<code>mount</code>还是<code>update</code>。</p>
<p>基于此原因，<code>beginWork</code>的工作可以分为两部分:</p>
<ul>
<li><strong>update</strong>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。</li>
<li><strong>mount</strong>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用current</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mount时：根据tag不同，创建不同的子Fiber节点</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LazyComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostText</span>:</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="comment">// ...省略其他类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="update-时-1">update 时</h4>
<p>我们可以看到，满足如下情况时<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的<code>子Fiber</code>，不需要新建<code>子Fiber</code>）</p>
<ol type="1">
<li><code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即<code>props</code>与<code>fiber.type</code>不变</li>
<li><code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前<code>Fiber节点</code>优先级不够，会在讲解<code>Scheduler</code>时介绍</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    oldProps !== newProps ||</span><br><span class="line">    <span class="title function_">hasLegacyContextChanged</span>() ||</span><br><span class="line">    (__DEV__ ? workInProgress.<span class="property">type</span> !== current.<span class="property">type</span> : <span class="literal">false</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">includesSomeLane</span>(renderLanes, updateLanes)) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (</span><br><span class="line">      workInProgress.<span class="property">tag</span></span><br><span class="line">      <span class="comment">// 省略处理</span></span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mount-时-1">mount 时</h4>
<p>当不满足优化路径时，我们就进入第二部分，新建<code>子Fiber</code>。</p>
<p>我们可以看到，根据<code>fiber.tag</code>不同，进入不同类型<code>Fiber</code>的创建逻辑。</p>
<blockquote>
<p>可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js">这里</a>看到tag对应的组件类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount时：根据tag不同，创建不同的Fiber节点</span></span><br><span class="line"><span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">LazyComponent</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">HostText</span>:</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="comment">// ...省略其他类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于我们常见的组件类型，如（<code>FunctionComponent</code>/<code>ClassComponent</code>/<code>HostComponent</code>），最终会进入<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233">reconcileChildren</a>方法。</p>
<h4 id="reconcilechildren">reconcileChildren</h4>
<p>从该函数名就能看出这是<code>Reconciler</code>模块的核心部分。那么他究竟做了什么呢？</p>
<ul>
<li>对于<code>mount</code>的组件，他会创建新的<code>子Fiber节点</code></li>
<li>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  nextChildren: any,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于mount的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于update的组件</span></span><br><span class="line">    workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.<span class="property">child</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，和<code>beginWork</code>一样，他也是通过<code>current === null ?</code>区分<code>mount</code>与<code>update</code>。</p>
<p>不论走哪个逻辑，最终他会生成新的<code>子Fiber节点</code>并赋值给<code>workInProgress.child</code>，作为本次<code>beginWork</code><a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158">返回值</a>，并作为下次<code>performUnitOfWork</code>执行时<code>workInProgress</code>的<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702">传参</a>。</p>
<blockquote>
<p>注意：值得一提的是，<code>mountChildFibers</code>与<code>reconcileChildFibers</code>这两个方法的逻辑基本一致。唯一的区别是：<code>reconcileChildFibers</code>会为生成的<code>Fiber节点</code>带上<code>effectTag</code>属性，而<code>mountChildFibers</code>不会。</p>
</blockquote>
<h4 id="effecttag">effectTag</h4>
<p>我们知道，<code>render阶段</code>的工作是在内存中进行，当工作结束后会通知<code>Renderer</code>需要执行的<code>DOM</code>操作。要执行<code>DOM</code>操作的具体类型就保存在<code>fiber.effectTag</code>中。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js">这里</a>看到effectTag对应的DOM操作</p>
</blockquote>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM需要插入到页面中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*                */</span> <span class="number">0b00000000000010</span>;</span><br><span class="line"><span class="comment">// DOM需要更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                   */</span> <span class="number">0b00000000000100</span>;</span><br><span class="line"><span class="comment">// DOM需要插入到页面中并更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PlacementAndUpdate</span> = <span class="comment">/*       */</span> <span class="number">0b00000000000110</span>;</span><br><span class="line"><span class="comment">// DOM需要删除</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*                 */</span> <span class="number">0b00000000001000</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过二进制表示<code>effectTag</code>，可以方便的使用位操作为<code>fiber.effectTag</code>赋值多个<code>effect</code>。</p>
</blockquote>
<p>那么，如果要通知<code>Renderer</code>将<code>Fiber节点</code>对应的<code>DOM节点</code>插入页面中，需要满足两个条件：</p>
<ol type="1">
<li><code>fiber.stateNode</code>存在，即<code>Fiber节点</code>中保存了对应的<code>DOM节点</code></li>
<li><code>(fiber.effectTag &amp; Placement) !== 0</code>，即<code>Fiber节点</code>存在<code>Placement effectTag</code></li>
</ol>
<p>我们知道，<code>mount</code>时，<code>fiber.stateNode === null</code>，且在<code>reconcileChildren</code>中调用的<code>mountChildFibers</code>不会为<code>Fiber节点</code>赋值<code>effectTag</code>。那么首屏渲染如何完成呢？</p>
<p>针对第一个问题，<code>fiber.stateNode</code>会在<code>completeWork</code>中创建，我们会在下一节介绍。</p>
<p>第二个问题的答案十分巧妙：假设<code>mountChildFibers</code>也会赋值<code>effectTag</code>，那么可以预见<code>mount</code>时整棵<code>Fiber树</code>所有节点都会有<code>Placement effectTag</code>。那么<code>commit</code>阶段在执行<code>DOM</code>操作时每个节点都会执行一次插入操作，这样大量的<code>DOM</code>操作是极低效的。</p>
<p>为了解决这个问题，在<code>mount</code>时只有<code>rootFiber</code>会赋值<code>Placement effectTag</code>，在<code>commit阶段</code>只会执行一次插入操作。</p>
<p>根 Fiber 节点 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/fiber-root-hxvml">Demo</a></p>
<p>借用上一节的
Demo，第一个进入<code>beginWork</code>方法的<code>Fiber节点</code>就是<code>rootFiber</code>，他的<code>alternate</code>指向<code>current rootFiber</code>（即他存在<code>current</code>）。</p>
<blockquote>
<p>为什么<code>rootFiber</code>节点存在<code>current</code>（即<code>rootFiber.alternate</code>），我们在双缓存机制一节
mount 时的第二步已经讲过</p>
</blockquote>
<p>由于存在<code>current</code>，<code>rootFiber</code>在<code>reconcileChildren</code>时会走<code>reconcileChildFibers</code>逻辑。</p>
<p>而之后通过<code>beginWork</code>创建的<code>Fiber节点</code>是不存在<code>current</code>的（即
<code>fiber.alternate === null</code>），会走<code>mountChildFibers</code>逻辑</p>
<h4 id="参考资料-6">参考资料</h4>
<figure>
<img src="/img/web/react-13.png" width="100%" loading="lazy" />
<figcaption style="text-align: center;">
beginWork流程图
</figcaption>
</figure>
<h3 id="completework">completeWork</h3>
<p>在流程概览一节我们了解组件在render阶段会经历<code>beginWork</code>与<code>completeWork</code>。</p>
<p>上一节我们讲解了组件执行<code>beginWork</code>后会创建<code>子Fiber节点</code>，节点上可能存在<code>effectTag</code>。</p>
<p>这一节让我们看看<code>completeWork</code>会做什么工作。</p>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673">这里</a>看到<code>completeWork</code>方法定义</p>
<h4 id="流程概览-1">流程概览</h4>
<p>类似<code>beginWork</code>，<code>completeWork</code>也是针对不同<code>fiber.tag</code>调用不同的处理逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LazyComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Mode</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Profiler</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ContextConsumer</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">MemoComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="title function_">updateHostContainer</span>(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...省略</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>
<p>我们重点关注页面渲染所必须的<code>HostComponent</code>（即原生<code>DOM组件</code>对应的<code>Fiber节点</code>），其他类型<code>Fiber</code>的处理留在具体功能实现时讲解。</p>
<h4 id="处理-hostcomponent">处理 HostComponent</h4>
<p>和<code>beginWork</code>一样，我们根据<code>current === null ?</code>判断是<code>mount</code>还是<code>update</code>。</p>
<p>同时针对<code>HostComponent</code>，判断<code>update</code>时我们还需要考虑<code>workInProgress.stateNode != null ?</code>（即该<code>Fiber节点</code>是否存在对应的<code>DOM节点</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">HostComponent</span>: &#123;</span><br><span class="line">  <span class="title function_">popHostContext</span>(workInProgress);</span><br><span class="line">  <span class="keyword">const</span> rootContainerInstance = <span class="title function_">getRootHostContainer</span>();</span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.<span class="property">type</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// update的情况</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// mount的情况</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="update-时-2">update 时</h4>
<p>当<code>update</code>时，<code>Fiber节点</code>已经存在对应<code>DOM节点</code>，所以不需要生成<code>DOM节点</code>。需要做的主要是处理<code>props</code>，比如：</p>
<ul>
<li><code>onClick</code>、<code>onChange</code>等回调函数的注册</li>
<li>处理<code>style prop</code></li>
<li>处理<code>DANGEROUSLY_SET_INNER_HTML prop</code></li>
<li>处理<code>children prop</code></li>
</ul>
<p>我们去掉一些当前不需要关注的功能（比如<code>ref</code>）。可以看到最主要的逻辑是调用<code>updateHostComponent</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// update的情况</span></span><br><span class="line">  <span class="title function_">updateHostComponent</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L225">这里</a>看到<code>updateHostComponent</code>方法定义。</p>
</blockquote>
<p>在<code>updateHostComponent</code>内部，被处理完的<code>props</code>会被赋值给<code>workInProgress.updateQueue</code>，并最终会在<code>commit阶段</code>被渲染在页面上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.<span class="property">updateQueue</span> = (<span class="attr">updatePayload</span>: any);</span><br></pre></td></tr></table></figure>
<p>其中<code>updatePayload</code>为数组形式，他的偶数索引的值为变化的<code>prop key</code>，奇数索引的值为变化的<code>prop value</code>。</p>
<blockquote>
<p>具体渲染过程见mutation 阶段一节</p>
</blockquote>
<p>updatePayload 属性 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/updatepayload-pzw36?file=/src/index.js">Demo</a></p>
<p>updateHostComponent方法内打印了Fiber节点对应的type与updatePayload。</p>
<p>你可以直观的感受updatePayload的数据结构</p>
<h4 id="mount-时-2">mount 时</h4>
<p>同样，我们省略了不相关的逻辑。可以看到，<code>mount</code>时的主要逻辑包括三个：</p>
<ul>
<li>为<code>Fiber节点</code>生成对应的<code>DOM节点</code></li>
<li>将子孙<code>DOM节点</code>插入刚生成的<code>DOM节点</code>中</li>
<li>与<code>update</code>逻辑中的<code>updateHostComponent</code>类似的处理<code>props</code>的过程</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略服务端渲染相关逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentHostContext = <span class="title function_">getHostContext</span>();</span><br><span class="line"><span class="comment">// 为fiber创建对应DOM节点</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">createInstance</span>(</span><br><span class="line">  type,</span><br><span class="line">  newProps,</span><br><span class="line">  rootContainerInstance,</span><br><span class="line">  currentHostContext,</span><br><span class="line">  workInProgress</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将子孙DOM节点插入刚生成的DOM节点中</span></span><br><span class="line"><span class="title function_">appendAllChildren</span>(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// DOM节点赋值给fiber.stateNode</span></span><br><span class="line">workInProgress.<span class="property">stateNode</span> = instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与update逻辑中的updateHostComponent类似的处理props的过程</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="title function_">finalizeInitialChildren</span>(</span><br><span class="line">    instance,</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext</span><br><span class="line">  )</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="title function_">markUpdate</span>(workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得上一节我们讲到：<code>mount</code>时只会在<code>rootFiber</code>存在<code>Placement effectTag</code>。那么<code>commit阶段</code>是如何通过一次插入<code>DOM``操作（对应一个Placement effectTag</code>）将整棵<code>DOM树</code>插入页面的呢？</p>
<p>原因就在于<code>completeWork</code>中的<code>appendAllChildren</code>方法。</p>
<p>由于<code>completeWork</code>属于“归”阶段调用的函数，每次调用<code>appendAllChildren</code>时都会将已生成的子孙<code>DOM节点</code>插入当前生成的<code>DOM节点</code>下。那么当“归”到<code>rootFiber</code>时，我们已经有一个构建好的离屏<code>DOM树</code>。</p>
<h4 id="effectlist">effectList</h4>
<p>至此<code>render阶段</code>的绝大部分工作就完成了。</p>
<p>还有一个问题：作为<code>DOM</code>操作的依据，<code>commit阶段</code>需要找到所有有<code>effectTag</code>的<code>Fiber节点</code>并依次执行<code>effectTag</code>对应操作。难道需要在<code>commit阶段</code>再遍历一次<code>Fiber树</code>寻找<code>effectTag !== null</code>的<code>Fiber节点</code>么？</p>
<p>这显然是很低效的。</p>
<p>为了解决这个问题，在<code>completeWork</code>的上层函数<code>completeUnitOfWork</code>中，每个执行完<code>completeWork</code>且存在<code>effectTag</code>的<code>Fiber节点</code>会被保存在一条被称为<code>effectList</code>的单向链表中。</p>
<p><code>effectList</code>中第一个<code>Fiber节点</code>保存在<code>fiber.firstEffect</code>，最后一个元素保存在<code>fiber.lastEffect</code>。</p>
<p>类似<code>appendAllChildren</code>，在“归”阶段，所有有<code>effectTag</code>的<code>Fiber节点</code>都会被追加在<code>effectList</code>中，最终形成一条以<code>rootFiber.firstEffec</code>t为起点的单向链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                       nextEffect         nextEffect</span><br><span class="line">rootFiber.firstEffect -----------&gt; fiber -----------&gt; fiber</span><br></pre></td></tr></table></figure>
<p>这样，在<code>commit阶段</code>只需要遍历<code>effectList</code>就能执行所有<code>effect</code>了。</p>
<p>你可以在这里看到这段代码逻辑。</p>
<p>借用<code>React</code>团队成员Dan
Abramov的话：<code>effectList</code>相较于<code>Fiber树</code>，就像圣诞树上挂的那一串彩灯。</p>
<h4 id="流程结尾">流程结尾</h4>
<p>至此，<code>render阶段</code>全部工作完成。在<code>performSyncWorkOnRoot</code>函数中<code>fiberRootNode</code>被传递给<code>commitRoot</code>方法，开启<code>commit阶段</code>工作流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">commitRoot</span>(root);</span><br></pre></td></tr></table></figure>
<p>代码见<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1107">这里</a>。</p>
<h4 id="参考资料-7">参考资料</h4>
<figure>
<img src="/img/web/react-14.png" width="100%" loading="lazy" />
<figcaption style="text-align: center;">
completeWork流程图
</figcaption>
</figure>
<h2 id="第四章-commit阶段">第四章 commit阶段</h2>
<h3 id="流程概览-2">流程概览</h3>
<p>上一章最后一节我们介绍了，<code>commitRoot</code>方法是<code>commit阶段</code>工作的起点。<code>fiberRootNode</code>会作为传参。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">commitRoot</span>(root);</span><br></pre></td></tr></table></figure>
<p>在<code>rootFiber.firstEffect</code>上保存了一条需要执行副作用的<code>Fiber节点</code>的单向链表<code>effectList</code>，这些<code>Fiber节点</code>的<code>updateQueue</code>中保存了变化的<code>props</code>。</p>
<p>这些副作用对应的`<code>DOM操作在</code>commit阶段`执行。</p>
<p>除此之外，一些生命周期钩子（比如<code>componentDidXXX</code>）、<code>hook</code>（比如<code>useEffect</code>）需要在<code>commit阶段</code>执行。</p>
<p><code>commit阶段</code>的主要工作（即<code>Renderer</code>的工作流程）分为三部分：</p>
<ul>
<li>before mutation 阶段（执行DOM操作前）</li>
<li>mutation 阶段（执行DOM操作）</li>
<li>layout 阶段（执行DOM操作后）</li>
</ul>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001">这里</a>看到<code>commit阶段</code>的完整代码</p>
<p>在<code>before mutation阶段</code>之前和<code>layout阶段</code>之后还有一些额外工作，涉及到比如<code>useEffect</code>的触发、<code>优先级</code>相关的重置、<code>ref</code>的绑定/解绑。</p>
<p>这些对我们当前属于超纲内容，为了内容完整性，在这节简单介绍。</p>
<h4 id="before-mutation-之前">before mutation 之前</h4>
<p>commitRootImpl方法中直到第一句if (firstEffect !== null)之前属于before
mutation之前。</p>
<p>我们大体看下他做的工作，现在你还不需要理解他们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务</span></span><br><span class="line">  <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// root指 fiberRootNode</span></span><br><span class="line"><span class="comment">// root.finishedWork指当前应用的rootFiber</span></span><br><span class="line"><span class="keyword">const</span> finishedWork = root.<span class="property">finishedWork</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡是变量名带lane的都是优先级相关</span></span><br><span class="line"><span class="keyword">const</span> lanes = root.<span class="property">finishedLanes</span>;</span><br><span class="line"><span class="keyword">if</span> (finishedWork === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">root.<span class="property">finishedWork</span> = <span class="literal">null</span>;</span><br><span class="line">root.<span class="property">finishedLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置Scheduler绑定的回调函数</span></span><br><span class="line">root.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line">root.<span class="property">callbackId</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> remainingLanes = <span class="title function_">mergeLanes</span>(finishedWork.<span class="property">lanes</span>, finishedWork.<span class="property">childLanes</span>);</span><br><span class="line"><span class="comment">// 重置优先级相关变量</span></span><br><span class="line"><span class="title function_">markRootFinished</span>(root, remainingLanes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。</span></span><br><span class="line"><span class="keyword">if</span> (rootsWithPendingDiscreteUpdates !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="title function_">hasDiscreteLanes</span>(remainingLanes) &amp;&amp;</span><br><span class="line">    rootsWithPendingDiscreteUpdates.<span class="title function_">has</span>(root)</span><br><span class="line">  ) &#123;</span><br><span class="line">    rootsWithPendingDiscreteUpdates.<span class="title function_">delete</span>(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置全局变量</span></span><br><span class="line"><span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgress = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = <span class="title class_">NoLanes</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将effectList赋值给firstEffect</span></span><br><span class="line"><span class="comment">// 由于每个fiber的effectList只包含他的子孙节点</span></span><br><span class="line"><span class="comment">// 所以根节点如果有effectTag则不会被包含进来</span></span><br><span class="line"><span class="comment">// 所以这里将有effectTag的根节点插入到effectList尾部</span></span><br><span class="line"><span class="comment">// 这样才能保证有effect的fiber都在effectList中</span></span><br><span class="line"><span class="keyword">let</span> firstEffect;</span><br><span class="line"><span class="keyword">if</span> (finishedWork.<span class="property">effectTag</span> &gt; <span class="title class_">PerformedWork</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finishedWork.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    finishedWork.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = finishedWork;</span><br><span class="line">    firstEffect = finishedWork.<span class="property">firstEffect</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    firstEffect = finishedWork;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 根节点没有effectTag</span></span><br><span class="line">  firstEffect = finishedWork.<span class="property">firstEffect</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>before mutation</code>之前主要做一些变量赋值，状态重置的工作。</p>
<p>这一长串代码我们只需要关注最后赋值的<code>firstEffect</code>，在<code>commit</code>的三个子阶段都会用到他。</p>
<h4 id="layout-之后">layout 之后</h4>
<p>接下来让我们简单看下<code>layout阶段</code>执行完后的代码，现在你还不需要理解他们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"></span><br><span class="line"><span class="comment">// useEffect相关</span></span><br><span class="line"><span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">  rootDoesHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">  rootWithPendingPassiveEffects = root;</span><br><span class="line">  pendingPassiveEffectsLanes = lanes;</span><br><span class="line">  pendingPassiveEffectsRenderPriority = renderPriorityLevel;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化相关</span></span><br><span class="line"><span class="keyword">if</span> (remainingLanes !== <span class="title class_">NoLanes</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化相关</span></span><br><span class="line"><span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDidHavePassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...检测无限循环的同步任务</span></span><br><span class="line"><span class="keyword">if</span> (remainingLanes === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度</span></span><br><span class="line"><span class="title function_">ensureRootIsScheduled</span>(root, <span class="title function_">now</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...处理未捕获错误及老版本遗留的边界问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行同步任务，这样同步任务不需要等到下次事件循环再执行</span></span><br><span class="line"><span class="comment">// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行</span></span><br><span class="line"><span class="comment">// 或useLayoutEffect</span></span><br><span class="line"><span class="title function_">flushSyncCallbackQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2195">这里</a>看到这段代码</p>
</blockquote>
<p>主要包括三点内容：</p>
<ol type="1">
<li><p><code>useEffect</code>相关的处理。</p>
<p>我们会在讲解<code>layout阶段</code>时讲解。</p></li>
<li><p>性能追踪相关。</p>
<p>源码里有很多和<code>interaction</code>相关的变量。他们都和追踪<code>React</code>渲染时间、性能相关，在<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/profiler.html">Profiler
API</a>和<a
target="_blank" rel="noopener" href="https://github.com/facebook/react-devtools/pull/1069">DevTools</a>中使用。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview">这里</a>看到<code>interaction 的定义</code></p>
</blockquote></li>
<li><p>在<code>commit阶段</code>会触发一些生命周期钩子（如
<code>componentDidXXX</code>）和<code>hook</code>（如<code>useLayoutEffect</code>、<code>useEffect</code>）。</p>
<p>在这些回调方法中可能触发新的更新，新的更新会开启新的render-commit流程。考虑如下
Demo:</p>
<p>[useLayoutEffect Demo]</p>
<p>在该 Demo 中我们点击页面中的数字，状态会先变为
0，再在<code>useLayoutEffect</code>回调中变为随机数。但在页面上数字不会变为
0，而是直接变为新的随机数。</p>
<p>这是因为<code>useLayoutEffect</code>会在<code>layout阶段</code>同步执行回调。回调中我们触发了状态更新<code>setCount(randomNum)</code>，这会重新调度一个同步任务。</p>
<p>该任务会在在如上<code>commitRoot</code>倒数第二行代码处被同步执行。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">flushSyncCallbackQueue</span>();</span><br></pre></td></tr></table></figure></p>
<p>所以我们看不到页面中元素先变为 0。</p>
<p>如果换成<code>useEffect</code>多点击几次就能看到区别。</p></li>
</ol>
<h3 id="before-mutation阶段">before mutation阶段</h3>
<p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p>
<p><code>Renderer</code>工作的阶段被称为<code>commit阶段</code>。<code>commit阶段</code>可以分为三个子阶段：</p>
<ul>
<li>before mutation阶段（执行DOM操作前）</li>
<li>mutation阶段（执行DOM操作）</li>
<li>layout阶段（执行DOM操作后）</li>
</ul>
<p>本节我们看看<code>before mutation阶段</code>（执行DOM操作前）都做了什么。</p>
<h4 id="概览">概览</h4>
<p><code>before mutation阶段</code>的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。</p>
<blockquote>
<p>这部分源码在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127">这里</a>。为了增加可读性，示例代码中删除了不相关的逻辑</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span></span><br><span class="line"><span class="keyword">const</span> previousLanePriority = <span class="title function_">getCurrentUpdateLanePriority</span>();</span><br><span class="line"><span class="title function_">setCurrentUpdateLanePriority</span>(<span class="title class_">SyncLanePriority</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span></span><br><span class="line"><span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">executionContext |= <span class="title class_">CommitContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理focus状态</span></span><br><span class="line">focusedInstanceHandle = <span class="title function_">prepareForCommit</span>(root.<span class="property">containerInfo</span>);</span><br><span class="line">shouldFireAfterActiveInstanceBlur = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// beforeMutation阶段的主函数</span></span><br><span class="line"><span class="title function_">commitBeforeMutationEffects</span>(finishedWork);</span><br></pre></td></tr></table></figure>
<p>我们重点关注<code>beforeMutation阶段</code>的主函数<code>commitBeforeMutationEffects</code>做了什么。</p>
<h4 id="commitbeforemutationeffects">commitBeforeMutationEffects</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ...focus blur相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getSnapshotBeforeUpdate</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Snapshot</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">      <span class="title function_">commitBeforeMutationEffectOnFiber</span>(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度useEffect</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">        rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体可以分为三部分：</p>
<ol type="1">
<li>处理<code>DOM节点</code>渲染/删除后的
<code>autoFocus</code>、<code>blur</code> 逻辑。</li>
<li>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</li>
<li>调度<code>useEffect</code>。</li>
</ol>
<p>我们讲解下2、3两点。</p>
<h4 id="调用getsnapshotbeforeupdate">调用getSnapshotBeforeUpdate</h4>
<p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名。</p>
<p>在该方法内会调用<code>getSnapshotBeforeUpdate</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222">这里</a>看到这段逻辑</p>
</blockquote>
<p>从<code>Reactv16</code>开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。</p>
<p>究其原因，是因为<code>Stack Reconciler</code>重构为<code>Fiber Reconciler</code>后，<code>render阶段</code>的任务可能中断/重新开始，对应的组件在<code>render阶段</code>的生命周期钩子（即<code>componentWillXXX</code>）可能触发多次。</p>
<p>这种行为和<code>Reactv15</code>不一致，所以标记为<code>UNSAFE_</code>。</p>
<blockquote>
<p>更详细的解释参照<a
target="_blank" rel="noopener" href="https://juejin.im/post/6847902224287285255#comment">这里</a></p>
</blockquote>
<p>为此，<code>React</code>提供了替代的生命周期钩子<code>getSnapshotBeforeUpdate</code>。</p>
<p>我们可以看见，<code>getSnapshotBeforeUpdate</code>是在<code>commit阶段</code>内的<code>before mutation阶段</code>调用的，由于<code>commit阶段</code>是同步的，所以不会遇到多次调用的问题。</p>
<h4 id="调度useeffect">调度useEffect</h4>
<p>在这几行代码内，<code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个优先级异步调度一个回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度useEffect</span></span><br><span class="line"><span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 触发useEffect</span></span><br><span class="line">      <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code>。</p>
<p>我们接下来讨论<code>useEffect</code>如何被异步调度，以及为什么要异步（而不是同步）调度。</p>
<h5 id="如何异步调度">如何异步调度</h5>
<p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>
<p>关于<code>flushPassiveEffects</code>的具体讲解参照<code>useEffect</code>与<code>useLayoutEffect</code>一节</p>
<p>在<code>completeWork</code>一节我们讲到，<code>effectList</code>中保存了需要执行副作用的<code>Fiber节点</code>。其中副作用包括</p>
<ul>
<li>插入DOM节点（Placement）</li>
<li>更新DOM节点（Update）</li>
<li>删除DOM节点（Deletion）</li>
</ul>
<p>除此外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或<code>useLayoutEffect</code>，他对应的<code>Fiber节点</code>也会被赋值<code>effectTag</code>。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js">这里</a>看到<code>hook</code>相关的<code>effectTag</code></p>
</blockquote>
<p>在<code>flushPassiveEffects</code>方法内部会遍历<code>rootWithPendingPassiveEffects</code>（即<code>effectList</code>）执行<code>effect</code>回调函数。</p>
<p>如果在此时直接执行，<code>rootWithPendingPassiveEffects === null</code>。</p>
<p>那么<code>rootWithPendingPassiveEffects</code>会在何时赋值呢？</p>
<p>在上一节<code>layout</code>之后的代码片段中会根据<code>rootDoesHavePassiveEffects === true?</code>决定是否赋值<code>rootWithPendingPassiveEffects</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"><span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">  rootDoesHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">  rootWithPendingPassiveEffects = root;</span><br><span class="line">  pendingPassiveEffectsLanes = lanes;</span><br><span class="line">  pendingPassiveEffectsRenderPriority = renderPriorityLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以整个<code>useEffect</code>异步调用分为三步：</p>
<ol type="1">
<li><code>before mutation阶段</code>在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li>
<li><code>layout阶段</code>之后将<code>effectList</code>赋值给<code>rootWithPendingPassiveEffects</code></li>
<li><code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code></li>
</ol>
<h5 id="为什么需要异步调用">为什么需要异步调用</h5>
<p>摘录自<code>React</code>文档<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects">effect
的执行时机</a>：</p>
<blockquote>
<p>与 componentDidMount、componentDidUpdate
不同的是，在浏览器完成布局与绘制之后，传给 useEffect
的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
</blockquote>
<p>可见，<code>useEffect</code>异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p>
<h4 id="总结-6">总结</h4>
<p>经过本节学习，我们知道了在<code>before mutation阶段</code>，会遍历<code>effectList</code>，依次执行：</p>
<ol type="1">
<li>处理<code>DOM节点</code>渲染/删除后的
<code>autoFocus</code>、<code>blur</code>逻辑</li>
<li>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</li>
<li>调度<code>useEffect</code></li>
</ol>
<h3 id="mutation阶段">mutation阶段</h3>
<p>终于到了执行DOM操作的<code>mutation阶段</code>。</p>
<h4 id="概览-1">概览</h4>
<p>类似<code>before mutation阶段</code>，<code>mutation阶段</code>也是遍历<code>effectList</code>，执行函数。这里执行的是<code>commitMutationEffects</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nextEffect = firstEffect;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">commitMutationEffects</span>(root, renderPriorityLevel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">invariant</span>(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">      <span class="title function_">captureCommitPhaseError</span>(nextEffect, error);</span><br><span class="line">      nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="commitmutationeffects">commitMutationEffects</h4>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2091">这里</a>看到<code>commitMutationEffects</code>源码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) &#123;</span><br><span class="line">  <span class="comment">// 遍历effectList</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ContentReset effectTag重置文字节点</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; <span class="title class_">ContentReset</span>) &#123;</span><br><span class="line">      <span class="title function_">commitResetTextContent</span>(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 effectTag 分别处理</span></span><br><span class="line">    <span class="keyword">const</span> primaryEffectTag =</span><br><span class="line">      effectTag &amp; (<span class="title class_">Placement</span> | <span class="title class_">Update</span> | <span class="title class_">Deletion</span> | <span class="title class_">Hydrating</span>);</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="comment">// 插入DOM</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Placement</span>: &#123;</span><br><span class="line">        <span class="title function_">commitPlacement</span>(nextEffect);</span><br><span class="line">        nextEffect.<span class="property">effectTag</span> &amp;= ~<span class="title class_">Placement</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入DOM 并 更新DOM</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">PlacementAndUpdate</span>: &#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        <span class="title function_">commitPlacement</span>(nextEffect);</span><br><span class="line"></span><br><span class="line">        nextEffect.<span class="property">effectTag</span> &amp;= ~<span class="title class_">Placement</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">        <span class="title function_">commitWork</span>(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Hydrating</span>: &#123;</span><br><span class="line">        nextEffect.<span class="property">effectTag</span> &amp;= ~<span class="title class_">Hydrating</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HydratingAndUpdate</span>: &#123;</span><br><span class="line">        nextEffect.<span class="property">effectTag</span> &amp;= ~<span class="title class_">Hydrating</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">        <span class="title function_">commitWork</span>(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新DOM</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Update</span>: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">        <span class="title function_">commitWork</span>(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除DOM</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Deletion</span>: &#123;</span><br><span class="line">        <span class="title function_">commitDeletion</span>(root, nextEffect, renderPriorityLevel);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>commitMutationEffects</code>会遍历<code>effectList</code>，对每个<code>Fiber节点</code>执行如下三个操作：</p>
<ol type="1">
<li>根据<code>ContentReset effectTag</code>重置文字节点</li>
<li>更新`ref</li>
<li>根据<code>effectTag</code>分别处理，其中<code>effectTag</code>包括(<code>Placement</code>
| <code>Update</code> | <code>Deletion</code> |
<code>Hydrating</code>)</li>
</ol>
<p>我们关注步骤三中的<code>Placement</code> | <code>Update</code> |
<code>Deletion</code>。<code>Hydrating</code>作为服务端渲染相关，我们先不关注</p>
<h4 id="placement-effect">Placement effect</h4>
<p>当<code>Fiber节点</code>含有<code>Placement effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要插入到页面中。</p>
<p>调用的方法为<code>commitPlacement</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156">这里</a>看到<code>commitPlacement</code>源码</p>
</blockquote>
<p>该方法所做的工作分为三步：</p>
<ol type="1">
<li><p>获取父级<code>DOM节点</code>。其中<code>finishedWork</code>为传入的<code>Fiber节点</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentFiber = <span class="title function_">getHostParentFiber</span>(finishedWork);</span><br><span class="line"><span class="comment">// 父级DOM节点</span></span><br><span class="line"><span class="keyword">const</span> parentStateNode = parentFiber.<span class="property">stateNode</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>获取<code>Fiber节点</code>的<code>DOM</code>兄弟节点</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = <span class="title function_">getHostSibling</span>(finishedWork);</span><br></pre></td></tr></table></figure></p></li>
<li><p>根据<code>DOM</code>兄弟节点是否存在决定调用<code>parentNode.insertBefore</code>或<code>parentNode.appendChild</code>执行<code>DOM</code>插入操作。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentStateNode是否是rootFiber</span></span><br><span class="line"><span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">  <span class="title function_">insertOrAppendPlacementNodeIntoContainer</span>(finishedWork, before, parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">insertOrAppendPlacementNode</span>(finishedWork, before, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>值得注意的是，<code>getHostSibling</code>（获取兄弟<code>DOM节点</code>）的执行很耗时，当在同一个父<code>Fiber节点</code>下依次执行多个插入操作，<code>getHostSibling</code>算法的复杂度为指数级。</p>
<p>这是由于<code>Fiber节点</code>不只包括<code>HostComponent</code>，所以<code>Fiber树</code>和渲染的<code>DOM树</code>节点并不是一一对应的。要从<code>Fiber节点</code>找到<code>DOM节点</code>很可能跨层级遍历。</p>
<p>考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Item</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;li&gt;&lt;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Item</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Fiber树</span><br><span class="line">          child      child      child       child</span><br><span class="line">rootFiber -----&gt; App -----&gt; div -----&gt; Item -----&gt; li</span><br><span class="line"></span><br><span class="line">// DOM树</span><br><span class="line">#root ---&gt; div ---&gt; li</span><br></pre></td></tr></table></figure>
<p>当在<code>div</code>的子节点<code>Item</code>前插入一个新节点<code>p</code>，即<code>App</code>变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&lt;/p&gt;</span><br><span class="line">      &lt;Item/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fiber树</span><br><span class="line">          child      child      child</span><br><span class="line">rootFiber -----&gt; App -----&gt; div -----&gt; p </span><br><span class="line">                                       | sibling       child</span><br><span class="line">                                       | -------&gt; Item -----&gt; li </span><br><span class="line">// DOM树</span><br><span class="line">#root ---&gt; div ---&gt; p</span><br><span class="line">             |</span><br><span class="line">               ---&gt; li</span><br></pre></td></tr></table></figure>
<p>此时<code>DOM节点</code>
<code>p</code>的兄弟节点为<code>li</code>，而<code>Fiber节点</code>
<code>p</code>对应的兄弟<code>DOM节点</code>为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberP.<span class="property">sibling</span>.<span class="property">child</span></span><br></pre></td></tr></table></figure>
<p>即<code>fiber p</code>的兄弟<code>fiber Item</code>的子<code>fiber li</code></p>
<h4 id="update-effect">Update effect</h4>
<p>当<code>Fiber节点</code>含有<code>Update effectTag</code>，意味着该<code>Fiber节点</code>需要更新。调用的方法为<code>commitWork</code>，他会根据<code>Fiber.tag</code>分别处理。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441">这里</a>看到<code>commitWork</code>源码</p>
</blockquote>
<p>这里我们主要关注<code>FunctionComponent</code>和<code>HostComponent</code>。</p>
<h5 id="functioncomponent-mutation">FunctionComponent mutation</h5>
<p>当<code>fiber.tag</code>为<code>FunctionComponent</code>，会调用<code>commitHookEffectListUnmount</code>。该方法会遍历<code>effectList</code>，执行所有<code>useLayoutEffect hook</code>的销毁函数。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314">这里</a>看到<code>commitHookEffectListUnmount</code>源码</p>
</blockquote>
<p>所谓“销毁函数”，见如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...一些副作用逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...这就是销毁函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你不需要很了解<code>useLayoutEffect</code>，我们会在下一节详细介绍。你只需要知道在<code>mutation阶段</code>会执行<code>useLayoutEffect</code>的销毁函数。</p>
<h5 id="hostcomponent-mutation">HostComponent mutation</h5>
<p>当<code>fiber.tag</code>为<code>HostComponent</code>，会调用<code>commitUpdate</code>。</p>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423">这里</a>看到<code>commitUpdate</code>源码</p>
<p>最终会在<code>updateDOMProperties</code>中将<code>render阶段</code>
<code>completeWork</code>中为<code>Fiber节点</code>赋值的<code>updateQueue</code>对应的内容渲染在页面上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">  <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 style</span></span><br><span class="line">  <span class="keyword">if</span> (propKey === <span class="variable constant_">STYLE</span>) &#123;</span><br><span class="line">    <span class="title function_">setValueForStyles</span>(domElement, propValue);</span><br><span class="line">  <span class="comment">// 处理 DANGEROUSLY_SET_INNER_HTML</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) &#123;</span><br><span class="line">    <span class="title function_">setInnerHTML</span>(domElement, propValue);</span><br><span class="line">  <span class="comment">// 处理 children</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="variable constant_">CHILDREN</span>) &#123;</span><br><span class="line">    <span class="title function_">setTextContent</span>(domElement, propValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 处理剩余 props</span></span><br><span class="line">    <span class="title function_">setValueForProperty</span>(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deletion-effect">Deletion effect</h4>
<p>当<code>Fiber节点</code>含有<code>Deletion effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要从页面中删除。调用的方法为<code>commitDeletion</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421">这里</a>看到<code>commitDeletion</code>源码</p>
</blockquote>
<p>该方法会执行如下操作：</p>
<ol type="1">
<li>递归调用<code>Fiber节点</code>及其子孙<code>Fiber节点</code>中<code>fiber.tag</code>为<code>ClassComponent</code>的<code>componentWillUnmount</code>生命周期钩子，从页面移除<code>Fiber节点</code>对应<code>DOM节点</code></li>
<li>解绑<code>ref</code></li>
<li>调度<code>useEffect</code>的销毁函数</li>
</ol>
<h4 id="总结-7">总结</h4>
<p>从这节我们学到，<code>mutation阶段</code>会遍历<code>effectList</code>，依次执行<code>commitMutationEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>。</p>
<h3 id="layout阶段">layout阶段</h3>
<p>该阶段之所以称为<code>layout</code>，因为该阶段的代码都是在<code>DOM</code>修改完成（<code>mutation阶段</code>完成）后执行的。</p>
<p>注意：由于 JS 的同步执行阻塞了主线程，所以此时 JS
已经可以获取到新的DOM，但是浏览器对新的<code>DOM</code>并没有完成渲染。</p>
<p>该阶段触发的生命周期钩子和<code>hook</code>可以直接访问到已经改变后的<code>DOM</code>，即该阶段是可以参与<code>DOM layout</code>的阶段。</p>
<h4 id="概览-2">概览</h4>
<p>与前两个阶段类似，<code>layout阶段</code>也是遍历<code>effectList</code>，执行函数。</p>
<p>具体执行的函数是<code>commitLayoutEffects</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="property">current</span> = finishedWork;</span><br><span class="line"></span><br><span class="line">nextEffect = firstEffect;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">commitLayoutEffects</span>(root, lanes);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(nextEffect !== <span class="literal">null</span>, <span class="string">&quot;Should be working on an effect.&quot;</span>);</span><br><span class="line">    <span class="title function_">captureCommitPhaseError</span>(nextEffect, error);</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">nextEffect = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="commitlayouteffects">commitLayoutEffects</h4>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302">这里</a>看到<code>commitLayoutEffects</code>源码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params">root: FiberRoot, committedLanes: Lanes</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用生命周期钩子和hook</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; (<span class="title class_">Update</span> | <span class="title class_">Callback</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="title function_">commitLayoutEffectOnFiber</span>(root, current, nextEffect, committedLanes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="title function_">commitAttachRef</span>(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>commitLayoutEffects</code>一共做了两件事：</p>
<ol type="1">
<li>commitLayoutEffectOnFiber（调用<strong>生命周期钩子</strong>和<strong>hook</strong>相关操作）</li>
<li>commitAttachRef（赋值 ref）</li>
</ol>
<h4 id="commitlayouteffectonfiber">commitLayoutEffectOnFiber</h4>
<p><code>commitLayoutEffectOnFiber</code>方法会根据<code>fiber.tag</code>对不同类型的节点分别处理。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459">这里</a>看到<code>commitLayoutEffectOnFiber</code>源码（<code>commitLayoutEffectOnFiber</code>为别名，方法原名为<code>commitLifeCycles</code>）</p>
</blockquote>
<ul>
<li><p>对于<code>ClassComponent</code>，他会通过<code>current === null?</code>区分是<code>mount</code>还是<code>update</code>，调用<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L538">componentDidMount</a>或<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L592">componentDidUpdate</a></p>
<p>触发状态更新的<code>this.setState</code>如果赋值了第二个参数回调函数，也会在此时调用。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">xxx</span>: <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i am update~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li>
<li><p>对于<code>FunctionComponent</code>及相关类型，他会调用<code>useLayoutEffect hook</code>的回调函数，调度<code>useEffect</code>的销毁与回调函数</p>
<blockquote>
<p>相关类型指特殊处理后的<code>FunctionComponent</code>，比如<code>ForwardRef</code>、<code>React.memo</code>包裹的<code>FunctionComponent</code></p>
</blockquote>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line"><span class="comment">// 以下都是FunctionComponent及相关类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">Block</span>: &#123;</span><br><span class="line">  <span class="comment">// 执行useLayoutEffect的回调函数</span></span><br><span class="line">  <span class="title function_">commitHookEffectListMount</span>(<span class="title class_">HookLayout</span> | <span class="title class_">HookHasEffect</span>, finishedWork);</span><br><span class="line">  <span class="comment">// 调度useEffect的销毁函数与回调函数</span></span><br><span class="line">  <span class="title function_">schedulePassiveEffects</span>(finishedWork);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L465-L491">这里</a>看到这段代码</p>
</blockquote>
<p>在上一节介绍<code>Update effect</code>时介绍过，<code>mutation阶段</code>会执行<code>useLayoutEffect hook</code>的销毁函数。</p>
<p>结合这里我们可以发现，<code>useLayoutEffect hook</code>从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。</p>
<p>而<code>useEffect</code>则需要先调度，在<code>Layout阶段</code>完成后再异步执行。</p>
<p>这就是<code>useLayoutEffect</code>与<code>useEffect</code>的区别。</p></li>
<li><p>对于<code>HostRoot</code>，即<code>rootFiber</code>，如果赋值了第三个参数回调函数，也会在此时调用。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>), <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i am mount~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="commitattachref">commitAttachRef</h4>
<p><code>commitLayoutEffects</code>会做的第二件事是<code>commitAttachRef</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L823">这里</a>看到<code>commitAttachRef</code>源码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DOM实例</span></span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">        instanceToUse = <span class="title function_">getPublicInstance</span>(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果ref是函数形式，调用回调函数</span></span><br><span class="line">      <span class="title function_">ref</span>(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果ref是ref实例形式，赋值ref.current</span></span><br><span class="line">      ref.<span class="property">current</span> = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑很简单：获取<code>DOM</code>实例，更新<code>ref</code>。</p>
<h4 id="current-fiber树切换">current Fiber树切换</h4>
<p>至此，整个<code>layout阶段</code>就结束了。</p>
<p>在结束本节的学习前，我们关注下这行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="property">current</span> = finishedWork;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2022">这里</a>看到这行代码</p>
</blockquote>
<p>在<strong>双缓存机制</strong>一节我们介绍过，<code>workInProgress Fiber树</code>在<code>commit阶段</code>完成渲染后会变为<code>current Fiber树</code>。这行代码的作用就是切换<code>fiberRootNode</code>指向的<code>current Fiber树</code>。</p>
<p>那么这行代码为什么在这里呢？（在<code>mutation阶段</code>结束后，<code>layout阶段</code>开始前。）</p>
<p>我们知道<code>componentWillUnmount</code>会在<code>mutation阶段</code>执行。此时<code>current Fiber树</code>还指向前一次更新的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>还是更新前的。</p>
<p><code>componentDidMount</code>和<code>componentDidUpdate</code>会在<code>layout阶段</code>执行。此时<code>current Fiber树</code>已经指向更新后的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>就是更新后的。</p>
<h4 id="总结-8">总结</h4>
<p>从这节我们学到，<code>layout阶段</code>会遍历<code>effectList</code>，依次执行<code>commitLayoutEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>并更新<code>ref</code>。</p>
<h4 id="参考资料-8">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://blog.logrocket.com/useeffect-vs-uselayouteffect-examples/">useeffect-vs-uselayouteffect-examples</a></p>
<p><a
target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect">hooks-reference.html#uselayouteffect</a></p>
<h1 id="实现篇">实现篇</h1>
<h2 id="第五章-diff算法选读">第五章 Diff算法（选读）</h2>
<h3 id="概览-3">概览</h3>
<p>在<code>beginWork</code>一节我们提到</p>
<blockquote>
<p>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code>。</p>
</blockquote>
<p>这一章我们讲解<code>Diff算法</code>的实现。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm">这里</a>看到Diff算法的介绍。</p>
</blockquote>
<p>一个DOM节点在某一时刻最多会有4个节点和他相关。</p>
<ol type="1">
<li><code>current Fiber</code>。如果该DOM节点已在页面中，<code>current Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</li>
<li><code>workInProgress Fiber</code>。如果该<code>DOM节点</code>将在本次更新中渲染到页面中，<code>workInProgress Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</li>
<li><code>DOM节点</code>本身。</li>
<li>JSX对象。即<code>ClassComponent</code>的<code>render</code>方法的返回结果，或<code>FunctionComponent</code>的调用结果。JSX对象中包含描述DOM节点的信息。</li>
</ol>
<p>Diff算法的本质是对比1和4，生成2。</p>
<h4 id="diff的瓶颈以及react如何应">Diff的瓶颈以及React如何应</h4>
<p>由于<code>Diff</code>操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为
O(n 3 )，其中n是树中元素的数量。</p>
<p>如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p>
<p>为了降低算法复杂度，React的diff会预设三个限制：</p>
<ol type="1">
<li><p>只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</p></li>
<li><p>两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。</p></li>
<li><p>开发者可以通过 key
prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新前</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&quot;ka&quot;</span>&gt;</span>ka<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">key</span>=<span class="string">&quot;song&quot;</span>&gt;</span>song<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新后</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">key</span>=<span class="string">&quot;song&quot;</span>&gt;</span>song<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&quot;ka&quot;</span>&gt;</span>ka<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。这符合限制2的设定，会销毁并新建。</p>
<p>但是当我们用key指明了节点前后对应关系后，React知道<code>key === "ka"</code>的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。</p>
<p>这就是React为了应对算法性能瓶颈做出的三条限制。</p>
<h4 id="diff是如何实现的">Diff是如何实现的</h4>
<p>我们从<code>Diff</code>的入口函数<code>reconcileChildFibers</code>出发，该函数会根据<code>newChild</code>（即JSX对象）类型调用不同的处理函数。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280">这里</a>看到<code>reconcileChildFibers</code>的源码。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据newChild类型选择不同diff函数处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChild: any,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="comment">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">      <span class="comment">// // ...省略其他case</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileSingleTextNode 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些其他情况调用处理函数</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上都没有命中，删除节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从同级的节点数量将Diff分为两类：</p>
<ol type="1">
<li>当<code>newChild</code>类型为<code>object</code>、<code>number</code>、<code>string</code>，代表同级只有一个节点</li>
<li>当<code>newChild</code>类型为<code>Array</code>，同级有多个节点</li>
</ol>
<p>在接下来两节我们会分别讨论这两类节点的Diff。</p>
<h3 id="单节点diff">单节点Diff</h3>
<p>对于单个节点，我们以类型<code>object</code>为例，会进入<code>reconcileSingleElement</code></p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141">这里</a>看到<code>reconcileSingleElement</code>源码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">  <span class="comment">// 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span><br><span class="line">  <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">      <span class="comment">// 调用 reconcileSingleElement 处理</span></span><br><span class="line">    <span class="comment">// ...其他case</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会做如下事情：</p>
<figure>
<img src="/img/web/react-15.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
-
</figcaption>
</figure>
<p>让我们看看第二步<strong>判断DOM节点是否可以复用</strong>是如何实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  element: ReactElement</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先判断是否存在对应DOM节点</span></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一次更新存在DOM节点，接下来判断是否可复用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先比较key是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">key</span> === key) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key相同，接下来比较type是否相同</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (child.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="comment">// ...省略case</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.<span class="property">elementType</span> === element.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="comment">// type相同则表示可以复用</span></span><br><span class="line">            <span class="comment">// 返回复用的fiber</span></span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// type不同则跳出switch</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代码执行到这里代表：key相同但是type不同</span></span><br><span class="line">      <span class="comment">// 将该fiber及其兄弟fiber标记为删除</span></span><br><span class="line">      <span class="title function_">deleteRemainingChildren</span>(returnFiber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// key不同，将该fiber标记为删除</span></span><br><span class="line">      <span class="title function_">deleteChild</span>(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新Fiber，并返回 ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们刚才提到的，React预设的限制么，</p>
<p>从代码可以看出，React通过先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用。</p>
<p>这里有个细节需要关注下：</p>
<p>当前页面有3个li，我们要全部删除，再插入一个p。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前页面显示的</span></span><br><span class="line">ul &gt; li * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这次需要更新的</span></span><br><span class="line">ul &gt; p</span><br></pre></td></tr></table></figure>
<p>由于本次更新时只有一个p，属于单一节点的Diff，会走上面介绍的代码逻辑。</p>
<p>在<code>reconcileSingleElement</code>中遍历之前的3个<code>fiber</code>（对应的<code>DOM</code>为3个<code>li</code>），寻找本次更新的p是否可以复用之前的3个<code>fiber</code>中某个的<code>DOM</code>。</p>
<p>当<code>key</code>相同且<code>type</code>不同时，代表我们已经找到本次更新的p对应的上次的<code>fiber</code>，但是<code>p</code>与<code>li type</code>不同，不能复用。既然唯一的可能性已经不能复用，则剩下的<code>fiber</code>都没有机会了，所以都需要标记删除。</p>
<p>当<code>key</code>不同时只代表遍历到的该<code>fiber</code>不能被<code>p</code>复用，后面还有兄弟<code>fiber</code>还没有遍历到。所以仅仅标记该<code>fiber</code>删除。</p>
<h3 id="练习题">练习题</h3>
<p>让我们来做几道习题巩固下吧：</p>
<p>请判断如下<code>JSX</code>对象对应的<code>DOM</code>元素是否可以复用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 习题1 更新前</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 更新后</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 习题2 更新前</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 更新后</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;ooo&quot;</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 习题3 更新前</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 更新后</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&quot;ooo&quot;</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 习题4 更新前</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>ka song<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 更新后</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>xiao bei<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>答案：</p>
<p>习题1: 未设置key prop默认 key =
null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则不能复用。</p>
<p>习题2: 更新前后key改变，不需要再判断type，不能复用。</p>
<p>习题3: 更新前后key改变，不需要再判断type，不能复用。</p>
<p>习题4:
更新前后key与type都未改变，可以复用。children变化，DOM的子元素需要更新。</p>
<h3 id="多节点diff">多节点Diff</h3>
<p>上一节我们介绍了单一节点的Diff，现在考虑我们有一个<code>FunctionComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">List</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的返回值JSX对象的children属性不是单一节点，而是包含四个对象的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>),</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;0&quot;</span>, <span class="attr">ref</span>: <span class="literal">null</span>, <span class="attr">props</span>: &#123;…&#125;, …&#125;</span><br><span class="line">      &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">ref</span>: <span class="literal">null</span>, <span class="attr">props</span>: &#123;…&#125;, …&#125;</span><br><span class="line">      &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">ref</span>: <span class="literal">null</span>, <span class="attr">props</span>: &#123;…&#125;, …&#125;</span><br><span class="line">      &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;li&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">ref</span>: <span class="literal">null</span>, <span class="attr">props</span>: &#123;…&#125;, …&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;ul&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，<code>reconcileChildFibers</code>的<code>newChild</code>参数类型为<code>Array</code>，在<code>reconcileChildFibers</code>函数内部对应如下情况：</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1352">这里</a>看到这段源码逻辑</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">   <span class="comment">// 调用 reconcileChildrenArray 处理</span></span><br><span class="line">   <span class="comment">// ...省略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这一节我们来看看，如何处理同级多个节点的Diff。</p>
<h4 id="概览-4">概览</h4>
<p>首先归纳下我们需要处理的情况：</p>
<p>我们以之前代表更新前的<code>JSX</code>对象，之后代表更新后的<code>JSX</code>对象</p>
<ul>
<li><p>情况1：节点更新</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;before&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 之后 情况1 —— 节点属性变化</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;after&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 之后 情况2 —— 节点类型更新</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>情况2：节点新增或减少</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 之后 情况1 —— 新增节点</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 之后 情况2 —— 删除节点</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>情况3：节点位置变化</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 之后</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>同级多个节点的<code>Diff</code>，一定属于以上三种情况中的一种或多种。</p>
<h4 id="diff的思路">Diff的思路</h4>
<p>该如何设计算法呢？如果让我设计一个Diff算法，我首先想到的方案是：</p>
<ol type="1">
<li>判断当前节点的更新属于哪种情况</li>
<li>如果是新增，执行新增逻辑</li>
<li>如果是删除，执行删除逻辑</li>
<li>如果是更新，执行更新逻辑</li>
</ol>
<p>按这个方案，其实有个隐含的前提——<strong>不同操作的优先级是相同的</strong></p>
<p>但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。</p>
<blockquote>
<p>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。
虽然本次更新的JSX对象
<code>newChildren</code>为数组形式，但是和<code>newChildren</code>中每个组件进行比较的是<code>current fiber</code>，同级的<code>Fiber节点</code>是由<code>sibling</code>指针链接形成的单链表，即不支持双指针遍历。
即
<code>newChildren[0]</code>与<code>fiber</code>比较，<code>newChildren[1]</code>与<code>fiber.sibling</code>比较。
所以无法使用双指针优化。</p>
</blockquote>
<p>基于以上原因，Diff算法的整体逻辑会经历两轮遍历：</p>
<p>第一轮遍历：处理更新的节点。</p>
<p>第二轮遍历：处理剩下的不属于更新的节点。</p>
<h4 id="第一轮遍历">第一轮遍历</h4>
<ol type="1">
<li><p>let i =
0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用。</p></li>
<li><p>如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历。</p></li>
<li><p>如果不可复用，分两种情况：</p>
<ul>
<li><code>key</code>不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</li>
<li><code>key</code>相同<code>type</code>不同导致不可复用，会将<code>oldFiber</code>标记为<code>DELETION</code>，并继续遍历</li>
</ul></li>
<li><p>如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，第一轮遍历结束。</p></li>
</ol>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818">这里</a>看到这轮遍历的源码</p>
</blockquote>
<p>当遍历结束后，会有两种结果：</p>
<h5 id="步骤3跳出的遍历">步骤3跳出的遍历</h5>
<p>此时newChildren没有遍历完，oldFiber也没有遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个节点可复用，遍历到<code>key === 2</code>的节点发现key改变，不可复用，跳出遍历，等待第二轮遍历处理。</p>
<p>此时<code>oldFiber</code>剩下<code>key === 1</code>、<code>key === 2</code>未遍历，<code>newChildren</code>剩下<code>key === 2</code>、<code>key === 1</code>未遍历。</p>
<h5 id="步骤4跳出的遍历">步骤4跳出的遍历</h5>
<p>可能<code>newChildren</code>遍历完，或oldFiber遍历完，或他们同时遍历完。</p>
<p>举个例子，考虑如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;a&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;b&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况1 —— newChildren与oldFiber都遍历完</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;bb&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况2 —— newChildren没遍历完，oldFiber遍历完</span><br><span class="line">// newChildren剩下 key===&quot;2&quot; 未遍历</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">className</span>=<span class="string">&quot;bb&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span> <span class="attr">className</span>=<span class="string">&quot;cc&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">// 之后 情况3 —— newChildren遍历完，oldFiber没遍历完</span><br><span class="line">// oldFiber剩下 key===&quot;1&quot; 未遍历</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span> <span class="attr">className</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
<h4 id="第二轮遍历">第二轮遍历</h4>
<p>对于第一轮遍历的结果，我们分别讨论：</p>
<ul>
<li><p><code>newChildren</code>与<code>oldFiber</code>同时遍历完</p>
<p>那就是最理想的情况：只需在第一轮遍历进行组件<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L825">更新</a>。此时Diff结束。</p></li>
<li><p><code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完</p>
<p>已有的DOM节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869">这里</a>看到这段源码逻辑</p>
</blockquote></li>
<li><p><code>newChildren</code>遍历完，<code>oldFiber</code>没遍历完</p>
<p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的<code>oldFiber</code>，依次标记<code>Deletion</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863">这里</a>看到这段源码逻辑</p>
</blockquote></li>
<li><p><code>newChildren</code>与<code>oldFiber</code>都没遍历完</p>
<p>这意味着有节点在这次更新中改变了位置。</p>
<p>这是Diff算法最精髓也是最难懂的部分。我们接下来会重点讲解。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L893">这里</a>看到这段源码逻辑</p>
</blockquote></li>
</ul>
<h3 id="处理移动的节点">处理移动的节点</h3>
<p>由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？</p>
<p>我们需要使用key。</p>
<p>为了快速的找到key对应的<code>oldFiber</code>，我们将所有还未处理的<code>oldFiber</code>存入以<code>key</code>为<code>key</code>，<code>oldFiber</code>为<code>value</code>的Map中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L890">这里</a>看到这段源码逻辑</p>
</blockquote>
<p>接下来遍历剩余的<code>newChildren</code>，通过<code>newChildren[i].key</code>就能在<code>existingChildren</code>中找到<code>key</code>相同的<code>oldFiber</code>。</p>
<h3 id="标记节点是否移动">标记节点是否移动</h3>
<p>既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？</p>
<p>我们的参照物是：最后一个可复用的节点在<code>oldFiber</code>中的位置索引（用变量<code>lastPlacedIndex</code>表示）。</p>
<p>由于本次更新中节点是按<code>newChildren</code>的顺序排列。在遍历<code>newChildren</code>过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在<code>lastPlacedIndex</code>对应的可复用的节点在本次更新中位置的后面。</p>
<p>那么我们只需要比较遍历到的可复用节点在上次更新时是否也在<code>lastPlacedIndex</code>对应的<code>oldFiber</code>后面，就能知道两次更新中这两个节点的相对位置改变没有。</p>
<p>我们用变量<code>oldIndex</code>表示遍历到的可复用节点在<code>oldFiber</code>中的位置索引。如果<code>oldIndex &lt; lastPlacedIndex</code>，代表本次更新该节点需要向右移动。</p>
<p><code>lastPlacedIndex</code>初始为0，每遍历一个可复用的节点，如果<code>oldIndex &gt;= lastPlacedIndex</code>，则<code>lastPlacedIndex = oldIndex</code>。</p>
<p>单纯文字表达比较晦涩，这里我们提供两个Demo，你可以对照着理解。</p>
<h3 id="demo1">Demo1</h3>
<p>在Demo中我们简化下书写，每个字母代表一个节点，字母的值代表节点的key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">// 之后</span><br><span class="line">acdb</span><br><span class="line"></span><br><span class="line">===第一轮遍历开始===</span><br><span class="line">a（之后）vs a（之前）  </span><br><span class="line">key不变，可复用</span><br><span class="line">此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0</span><br><span class="line">所以 lastPlacedIndex = 0;</span><br><span class="line"></span><br><span class="line">继续第一轮遍历...</span><br><span class="line"></span><br><span class="line">c（之后）vs b（之前）  </span><br><span class="line">key改变，不能复用，跳出第一轮遍历</span><br><span class="line">此时 lastPlacedIndex === 0;</span><br><span class="line">===第一轮遍历结束===</span><br><span class="line"></span><br><span class="line">===第二轮遍历开始===</span><br><span class="line">newChildren === cdb，没用完，不需要执行删除旧节点</span><br><span class="line">oldFiber === bcd，没用完，不需要执行插入新节点</span><br><span class="line"></span><br><span class="line">将剩余oldFiber（bcd）保存为map</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：bcd</span><br><span class="line">// 当前newChildren：cdb</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">key === c 在 oldFiber中存在</span><br><span class="line">const oldIndex = c（之前）.index;</span><br><span class="line">此时 oldIndex === 2;  // 之前节点为 abcd，所以c.index === 2</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line"></span><br><span class="line">如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动</span><br><span class="line">并将 lastPlacedIndex = oldIndex;</span><br><span class="line">如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动</span><br><span class="line"></span><br><span class="line">在例子中，oldIndex 2 &gt; lastPlacedIndex 0，</span><br><span class="line">则 lastPlacedIndex = 2;</span><br><span class="line">c节点位置不变</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：bd</span><br><span class="line">// 当前newChildren：db</span><br><span class="line"></span><br><span class="line">key === d 在 oldFiber中存在</span><br><span class="line">const oldIndex = d（之前）.index;</span><br><span class="line">oldIndex 3 &gt; lastPlacedIndex 2 // 之前节点为 abcd，所以d.index === 3</span><br><span class="line">则 lastPlacedIndex = 3;</span><br><span class="line">d节点位置不变</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：b</span><br><span class="line">// 当前newChildren：b</span><br><span class="line"></span><br><span class="line">key === b 在 oldFiber中存在</span><br><span class="line">const oldIndex = b（之前）.index;</span><br><span class="line">oldIndex 1 &lt; lastPlacedIndex 3 // 之前节点为 abcd，所以b.index === 1</span><br><span class="line">则 b节点需要向右移动</span><br><span class="line">===第二轮遍历结束===</span><br><span class="line"></span><br><span class="line">最终acd 3个节点都没有移动，b节点被标记为移动</span><br></pre></td></tr></table></figure>
<h3 id="demo2">Demo2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">// 之后</span><br><span class="line">dabc</span><br><span class="line"></span><br><span class="line">===第一轮遍历开始===</span><br><span class="line">d（之后）vs a（之前）  </span><br><span class="line">key改变，不能复用，跳出遍历</span><br><span class="line">===第一轮遍历结束===</span><br><span class="line"></span><br><span class="line">===第二轮遍历开始===</span><br><span class="line">newChildren === dabc，没用完，不需要执行删除旧节点</span><br><span class="line">oldFiber === abcd，没用完，不需要执行插入新节点</span><br><span class="line"></span><br><span class="line">将剩余oldFiber（abcd）保存为map</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：abcd</span><br><span class="line">// 当前newChildren dabc</span><br><span class="line"></span><br><span class="line">key === d 在 oldFiber中存在</span><br><span class="line">const oldIndex = d（之前）.index;</span><br><span class="line">此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 3 &gt; lastPlacedIndex 0</span><br><span class="line">则 lastPlacedIndex = 3;</span><br><span class="line">d节点位置不变</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：abc</span><br><span class="line">// 当前newChildren abc</span><br><span class="line"></span><br><span class="line">key === a 在 oldFiber中存在</span><br><span class="line">const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0</span><br><span class="line">此时 oldIndex === 0;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 0 &lt; lastPlacedIndex 3</span><br><span class="line">则 a节点需要向右移动</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：bc</span><br><span class="line">// 当前newChildren bc</span><br><span class="line"></span><br><span class="line">key === b 在 oldFiber中存在</span><br><span class="line">const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1</span><br><span class="line">此时 oldIndex === 1;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 1 &lt; lastPlacedIndex 3</span><br><span class="line">则 b节点需要向右移动</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：c</span><br><span class="line">// 当前newChildren c</span><br><span class="line"></span><br><span class="line">key === c 在 oldFiber中存在</span><br><span class="line">const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2</span><br><span class="line">此时 oldIndex === 2;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 2 &lt; lastPlacedIndex 3</span><br><span class="line">则 c节点需要向右移动</span><br><span class="line"></span><br><span class="line">===第二轮遍历结束===</span><br></pre></td></tr></table></figure>
<p>可以看到，我们以为从 <code>abcd</code> 变为
<code>dabc</code>，只需要将<code>d</code>移动到前面。</p>
<p>但实际上<code>React</code>保持<code>d</code>不变，将<code>abc</code>分别移动到了<code>d</code>的后面。</p>
<p>从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。</p>
<h2 id="第六章-状态更新">第六章 状态更新</h2>
<h3 id="流程概览-3">流程概览</h3>
<p>经过前几章的学习，我们终于有足够的前置知识理解<strong>状态更新</strong>的整个流程。</p>
<p>这一章我们看看几种常见的触发状态更新的方法是如何完成工作的。</p>
<h4 id="几个关键节点">几个关键节点</h4>
<p>在开始学习前，我们先了解源码中几个关键节点（即几个关键函数的调用）。通过这章的学习，我们会将这些关键节点的调用路径串起来。</p>
<p>先从我们所熟知的概念开始。</p>
<h5 id="render阶段的开始">render阶段的开始</h5>
<p>我们在render阶段流程概览一节讲到，</p>
<p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p>
<h5 id="commit阶段的开始">commit阶段的开始</h5>
<p>我们在<code>commit阶段</code>流程概览一节讲到，</p>
<p><code>commit阶段</code>开始于<code>commitRoot</code>方法的调用。其中<code>rootFiber</code>会作为传参。</p>
<p>我们已经知道，<code>render阶段</code>完成后会进入<code>commit阶段</code>。让我们继续补全从触发状态更新到<code>render阶段</code>的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">触发状态更新（根据场景调用不同方法）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">    ？</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">commit阶段（`commitRoot`）</span><br></pre></td></tr></table></figure>
<h4 id="创建update对象">创建Update对象</h4>
<p>在React中，有如下方法可以触发状态更新（排除SSR相关）：</p>
<ul>
<li>ReactDOM.render</li>
<li>this.setState</li>
<li>this.forceUpdate</li>
<li>useState</li>
<li>useReducer</li>
</ul>
<p>这些方法调用的场景各不相同，他们是如何接入同一套<strong>状态更新机制</strong>呢？</p>
<p>答案是：每次状态更新都会创建一个保存更新状态相关内容的对象，我们叫他<code>Update</code>。在<code>render阶段</code>的<code>beginWork</code>中会根据<code>Update</code>计算新的<code>state</code>。</p>
<p>我们会在下一节详细讲解<code>Update</code>。</p>
<h4 id="从fiber到root">从fiber到root</h4>
<p>现在触发状态更新的<code>fiber</code>上已经包含<code>Update</code>对象。</p>
<p>我们知道，<code>render阶段</code>是从<code>rootFiber</code>开始向下遍历。那么如何从触发状态更新的<code>fiber</code>得到<code>rootFiber</code>呢？</p>
<p>答案是：调用<code>markUpdateLaneFromFiberToRoot</code>方法。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636">这里</a>看到<code>markUpdateLaneFromFiberToRoot</code>的源码</p>
</blockquote>
<p>该方法做的工作可以概括为：从<strong>触发状态更新的fiber</strong>一直向上遍历到<code>rootFiber</code>，并返回<code>rootFiber</code>。</p>
<p>由于不同更新优先级不尽相同，所以过程中还会更新遍历到的<code>fiber</code>的优先级。这对于我们当前属于超纲内容。</p>
<h4 id="调度更新">调度更新</h4>
<p>现在我们拥有一个<code>rootFiber</code>，该<code>rootFiber</code>对应的<code>Fiber树</code>中某个<code>Fiber节点</code>包含一个<code>Update</code>。</p>
<p>接下来通知<code>Scheduler</code>根据更新的优先级，决定以同步还是异步的方式调度本次更新。</p>
<p>这里调用的方法是<code>ensureRootIsScheduled</code>。</p>
<p>以下是<code>ensureRootIsScheduled</code>最核心的一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCallbackPriority === <span class="title class_">SyncLanePriority</span>) &#123;</span><br><span class="line">  <span class="comment">// 任务已经过期，需要同步执行render阶段</span></span><br><span class="line">  newCallbackNode = <span class="title function_">scheduleSyncCallback</span>(</span><br><span class="line">    performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root)</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 根据任务优先级异步执行render阶段</span></span><br><span class="line">  <span class="keyword">var</span> schedulerPriorityLevel = <span class="title function_">lanePriorityToSchedulerPriority</span>(</span><br><span class="line">    newCallbackPriority</span><br><span class="line">  );</span><br><span class="line">  newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602">这里</a>看到<code>ensureRootIsScheduled</code>的源码</p>
</blockquote>
<p>其中，<code>scheduleCallback</code>和<code>scheduleSyncCallback</code>会调用<code>Scheduler</code>提供的调度方法根据优先级调度回调函数执行。</p>
<p>可以看到，这里调度的回调函数为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br><span class="line">performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br></pre></td></tr></table></figure>
<p>即<code>render阶段</code>的入口函数。</p>
<p>至此，状态更新就和我们所熟知的<code>render阶段</code>连接上了。</p>
<h5 id="总结-9">总结</h5>
<p>让我们梳理下<strong>状态更新</strong>的整个调用路径的关键节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">触发状态更新（根据场景调用不同方法）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">创建Update对象（接下来三节详解）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">从fiber到root（`markUpdateLaneFromFiberToRoot`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">调度更新（`ensureRootIsScheduled`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">commit阶段（`commitRoot`）</span><br></pre></td></tr></table></figure>
<h4 id="总结-10">总结</h4>
<p>本节我们了解了<strong>状态更新</strong>的整个流程。</p>
<p>在接下来三节中，我们会花大量篇幅讲解<code>Update</code>的工作机制，因为他是构成<code>React concurrent mode</code>的核心机制之一。</p>
<h3 id="心智模型">心智模型</h3>
<p>在深入源码前，让我们先建立<strong>更新机制</strong>的<strong>心智模型</strong>。</p>
<p>在后面两节讲解源码时，我们会将代码与<strong>心智模型</strong>联系上，方便你更好理解。</p>
<h4 id="同步更新的react">同步更新的React</h4>
<p>我们可以将<strong>更新机制</strong>类比<strong>代码版本控制</strong>。</p>
<p>在没有代码版本控制前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）。</p>
<figure>
<img src="/img/web/react-16.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
版本控制
</figcaption>
</figure>
<p>为了修复这个bug，我们需要首先将之前的代码提交。</p>
<p>在<code>React</code>中，所有通过<code>ReactDOM.render</code>创建的应用（其他创建应用的方式参考<code>ReactDOM.render</code>一节）都是通过类似的方式更新状态。</p>
<p>即没有优先级概念，高优更新（红色节点）需要排在其他更新后面执行。</p>
<h4 id="并发更新的react">并发更新的React</h4>
<p>当有了代码版本控制，有紧急线上bug需要修复时，我们暂存当前分支的修改，在master分支修复bug并紧急上线。</p>
<figure>
<img src="/img/web/react-17.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
版本控制
</figcaption>
</figure>
<p>bug修复上线后通过git
rebase命令和开发分支连接上。开发分支基于修复bug的版本继续开发。</p>
<figure>
<img src="/img/web/react-18.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
版本控制
</figcaption>
</figure>
<p>在<code>React</code>中，通过<code>ReactDOM.createBlockingRoot</code>和<code>ReactDOM.createRoot</code>创建的应用会采用并发的方式更新状态。</p>
<p>高优更新（红色节点）中断正在进行中的低优更新（蓝色节点），先完成<code>render - commit</code>流程。</p>
<p>待高优更新完成后，低优更新基于高优更新的结果重新更新。</p>
<p>接下来两节我们会从源码角度讲解这套并发更新是如何实现的。</p>
<h4 id="参考资料-9">参考资料</h4>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=v6iR3Zk4oDY">外网 英文 React
Core Team Dan介绍React未来发展方向</a></p>
<h3 id="update">Update</h3>
<p>通过本章第一节学习，我们知道状态更新流程开始后首先会创建Update对象。</p>
<p>本节我们学习Update的结构与工作流程。</p>
<blockquote>
<p>你可以将<code>Update</code>类比心智模型中的一次<code>commit</code>。</p>
</blockquote>
<h4 id="update的分类">Update的分类</h4>
<p>我们先来了解<code>Update</code>的结构。</p>
<p>首先，我们将可以触发更新的方法所隶属的组件分类：</p>
<ul>
<li>ReactDOM.render —— HostRoot</li>
<li>this.setState —— ClassComponent</li>
<li>this.forceUpdate —— ClassComponent</li>
<li>useState —— FunctionComponent</li>
<li>useReducer —— FunctionComponent</li>
</ul>
<p>可以看到，一共三种组件（<code>HostRoot</code> |
<code>ClassComponent</code> |
<code>FunctionComponent</code>）可以触发更新。</p>
<p>由于不同类型组件工作方式不同，所以存在两种不同结构的<code>Update</code>，其中<code>ClassComponent</code>与<code>HostRoot</code>共用一套<code>Update</code>结构，<code>FunctionComponent</code>单独使用一种<code>Update</code>结构。</p>
<p>虽然他们的结构不同，但是他们工作机制与工作流程大体相同。在本节我们介绍前一种<code>Update</code>，<code>FunctionComponent</code>对应的<code>Update</code>在<code>Hooks</code>章节介绍。</p>
<h4 id="update的结构">Update的结构</h4>
<p><code>ClassComponent</code>与<code>HostRoot</code>（即<code>rootFiber.tag</code>对应类型）共用同一种<code>Update</code>结构。</p>
<p>对应的结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;*&gt; = &#123;</span><br><span class="line">  eventTime,</span><br><span class="line">  lane,</span><br><span class="line">  suspenseConfig,</span><br><span class="line">  <span class="attr">tag</span>: <span class="title class_">UpdateState</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">callback</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Update</code>由<code>createUpdate</code>方法返回，你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.old.js#L189">这里</a>看到<code>createUpdate</code>的源码</p>
</blockquote>
<p>字段意义如下：</p>
<ul>
<li>eventTime：任务时间，通过performance.now()获取的毫秒数。由于该字段在未来会重构，当前我们不需要理解他。</li>
<li>lane：优先级相关字段。当前还不需要掌握他，只需要知道不同Update优先级可能是不同的。</li>
</ul>
<blockquote>
<p>你可以将<code>lane</code>类比心智模型中需求的<strong>紧急程度</strong>。</p>
</blockquote>
<ul>
<li>suspenseConfig：Suspense相关，暂不关注。</li>
<li>tag：更新的类型，包括<code>UpdateState</code> |
<code>ReplaceState</code> | <code>ForceUpdate</code> |
<code>CaptureUpdate</code>。</li>
<li>payload：更新挂载的数据，不同类型组件挂载的数据不同。对于<code>ClassComponent</code>，<code>payload</code>为<code>this.setState</code>的第一个传参。对于<code>HostRoot</code>，`<code>payload为</code>ReactDOM.render`的第一个传参。</li>
<li>callback：更新的回调函数。即在<code>commit 阶段</code>的
<code>layout</code> 子阶段一节中提到的回调函数。</li>
<li>next：与其他<code>Update</code>连接形成链表。</li>
</ul>
<h4 id="update与fiber的联系">Update与Fiber的联系</h4>
<p>我们发现，<code>Update</code>存在一个连接其他<code>Update</code>形成链表的字段<code>next</code>。联系<code>React</code>中另一种以链表形式组成的结构<code>Fiber</code>，他们之间有什么关联么？</p>
<p>答案是肯定的。</p>
<p>从双缓存机制一节我们知道，<code>Fiber节点</code>组成<code>Fiber树</code>，页面中最多同时存在两棵<code>Fiber树</code>：</p>
<ul>
<li>代表当前页面状态的<code>current Fiber树</code></li>
<li>代表正在<code>render阶段</code>的<code>workInProgress Fiber树</code></li>
</ul>
<p>类似<code>Fiber节点</code>组成<code>Fiber树</code>，<code>Fiber节点</code>上的多个<code>Update</code>会组成链表并被包含在<code>fiber.updateQueue</code>中。</p>
<p>什么情况下一个Fiber节点会存在多个Update？</p>
<p>你可能疑惑为什么一个Fiber节点会存在多个Update。这其实是很常见的情况。</p>
<p>在这里介绍一种最简单的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个<code>ClassComponent</code>中触发<code>this.onClick</code>方法，方法内部调用了两次<code>this.setState</code>。这会在该<code>fiber</code>中产生两个<code>Update</code>。</p>
<p><code>Fiber节点</code>最多同时存在两个<code>updateQueue</code>：</p>
<ul>
<li><code>current fiber</code>保存的<code>updateQueue</code>即<code>current updateQueue</code></li>
<li><code>workInProgress fiber</code>保存的<code>updateQueue</code>即<code>workInProgress updateQueue</code></li>
</ul>
<p>在<code>commit阶段</code>完成页面渲染后，<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，<code>workInProgress Fiber树</code>内<code>Fiber节点</code>的<code>updateQueue</code>就变成<code>current updateQueue</code>。</p>
<h4 id="updatequeue">updateQueue</h4>
<p><code>updateQueue</code>有三种类型，其中针对<code>HostComponent</code>的类型我们在<code>completeWork</code>一节介绍过。</p>
<p>剩下两种类型和Update的两种类型对应。</p>
<p><code>ClassComponent</code>与<code>HostRoot</code>使用的<code>UpdateQueue</code>结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">State</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">baseState</span>: fiber.<span class="property">memoizedState</span>,</span><br><span class="line">    <span class="attr">firstBaseUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastBaseUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">shared</span>: &#123;</span><br><span class="line">      <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">effects</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>UpdateQueue</code>由<code>initializeUpdateQueue</code>方法返回，你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L157">这里</a>看到<code>initializeUpdateQueue</code>的源码</p>
</blockquote>
<p>字段说明如下：</p>
<ul>
<li><p>baseState：本次更新前该Fiber节点的state，Update基于该state计算更新后的state。</p>
<p>你可以将<code>baseState</code>类比心智模型中的<code>master</code>分支</p></li>
<li><p><code>firstBaseUpdate</code>与<code>lastBaseUpdate</code>：本次更新前该<code>Fiber节点</code>已保存的<code>Update</code>。以链表形式存在，链表头为<code>firstBaseUpdate</code>，链表尾为<code>lastBaseUpdate</code>。之所以在更新产生前该<code>Fiber节点</code>内就存在<code>Update</code>，是由于某些<code>Update</code>优先级较低所以在上次<code>render阶段</code>由<code>Update</code>计算<code>state</code>时被跳过。</p>
<p>你可以将<code>baseUpdate</code>类比心智模型中执行<code>git rebase</code>基于的<code>commit</code>（节点D）。</p></li>
<li><p><code>shared.pending</code>：触发更新时，产生的<code>Update</code>会保存在<code>shared.pending</code>中形成单向环状链表。当由<code>Update</code>计算<code>state</code>时这个环会被剪开并连接在<code>lastBaseUpdate</code>后面。</p>
<p>你可以将<code>shared.pending</code>类比心智模型中本次需要提交的<code>commit</code>（节点ABC）。</p></li>
<li><p><code>effects</code>：数组。保存<code>update.callback !== null</code>的<code>Update</code>。</p></li>
</ul>
<h4 id="例子-1">例子</h4>
<p><code>updateQueue</code>相关代码逻辑涉及到大量链表操作，比较难懂。在此我们举例对<code>updateQueue</code>的工作流程讲解下。</p>
<p>假设有一个<code>fiber</code>刚经历<code>commit阶段</code>完成渲染。</p>
<p>该<code>fiber</code>上有两个由于优先级过低所以在上次的<code>render阶段</code>并没有处理的<code>Update</code>。他们会成为下次更新的<code>baseUpdate</code>。</p>
<p>我们称其为<code>u1</code>和<code>u2</code>，其中<code>u1.next === u2</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">firstBaseUpdate</span> === u1;</span><br><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">lastBaseUpdate</span> === u2;</span><br><span class="line">u1.<span class="property">next</span> === u2;</span><br></pre></td></tr></table></figure>
<p>我们用<code>--&gt;</code>表示链表的指向：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">baseUpdate</span>: u1 --&gt; u2</span><br></pre></td></tr></table></figure>
<p>现在我们在<code>fiber</code>上触发两次状态更新，这会先后产生两个新的<code>Update</code>，我们称为<code>u3</code>和<code>u4</code>。</p>
<p>每个 <code>update</code> 都会通过 <code>enqueueUpdate</code>
方法插入到 <code>updateQueue</code> 队列上</p>
<p>当插入<code>u3</code>后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">shared</span>.<span class="property">pending</span> === u3;</span><br><span class="line">u3.<span class="property">next</span> === u3;</span><br></pre></td></tr></table></figure>
<p><code>shared.pending</code>的环状链表，用图表示为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">shared</span>.<span class="property">pending</span>:   u3 ─────┐ </span><br><span class="line">                                     ^      |                                    </span><br><span class="line">                                     └──────┘</span><br></pre></td></tr></table></figure>
<p>接着插入<code>u4</code>之后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">shared</span>.<span class="property">pending</span> === u4;</span><br><span class="line">u4.<span class="property">next</span> === u3;</span><br><span class="line">u3.<span class="property">next</span> === u4;</span><br></pre></td></tr></table></figure>
<p><code>shared.pending</code>是环状链表，用图表示为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">shared</span>.<span class="property">pending</span>:   u4 ──&gt; u3</span><br><span class="line">                                     ^      |                                    </span><br><span class="line">                                     └──────┘</span><br></pre></td></tr></table></figure>
<p><code>shared.pending</code>
会保证始终指向最后一个插入的<code>update</code>，你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L208">这里</a>看到<code>enqueueUpdate</code>的源码</p>
<p>更新调度完成后进入<code>render阶段</code>。</p>
<p>此时<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">baseUpdate</span>: u1 --&gt; u2 --&gt; u3 --&gt; u4</span><br></pre></td></tr></table></figure>
<p>接下来遍历<code>updateQueue.baseUpdate</code>链表，以<code>fiber.updateQueue.baseState</code>为初始<code>state</code>，依次与遍历到的每个<code>Update</code>计算并产生新的<code>state</code>（该操作类比<code>Array.prototype.reduce</code>）。</p>
<p>在遍历时如果有优先级低的<code>Update</code>会被跳过。</p>
<p>当遍历完成后获得的<code>state</code>，就是该<code>Fiber节点</code>在本次更新的<code>state</code>（源码中叫做<code>memoizedState</code>）。</p>
<blockquote>
<p><code>render阶段</code>的<code>Update</code>操作由<code>processUpdateQueue</code>完成，你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L405">这里</a>看到<code>processUpdateQueue</code>的源码</p>
</blockquote>
<p><code>state</code>的变化在<code>render阶段</code>产生与上次更新不同的<code>JSX</code>对象，通过<code>Diff算法</code>产生<code>effectTag</code>，在<code>commit阶段</code>渲染在页面上。</p>
<p>渲染完成后<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，整个更新流程结束。</p>
<h3 id="深入理解优先级">深入理解优先级</h3>
<p>通过更新的心智模型，我们了解到<strong>更新</strong>具有<strong>优先级</strong>。</p>
<p>那么什么是<strong>优先级</strong>？<strong>优先级</strong>以什么为依据？如何通过<strong>优先级</strong>决定哪个状态应该先被<strong>更新</strong>？</p>
<p>本节我们会详细讲解。</p>
<h4 id="什么是优先级">什么是优先级</h4>
<p>在<code>React</code>
理念一节我们聊到<code>React</code>将人机交互研究的结果整合到真实的UI中。具体到<code>React</code>运行上这是什么意思呢？</p>
<p>状态更新由用户交互产生，用户心里对交互执行顺序有个预期。<code>React</code>根据人机交互研究的结果中用户对交互的预期顺序为交互产生的状态更新赋予不同优先级。</p>
<p>具体如下：</p>
<ul>
<li>生命周期方法：同步执行。</li>
<li>受控的用户输入：比如输入框内输入文字，同步执行。</li>
<li>交互事件：比如动画，高优先级执行。</li>
<li>其他：比如数据请求，低优先级执行。</li>
</ul>
<h4 id="如何调度优先级">如何调度优先级</h4>
<p>我们在新的 <code>React</code>
结构一节讲到，<code>React</code>通过<code>Scheduler</code>调度任务。</p>
<p>具体到代码，每当需要调度任务时，<code>React</code>会调用<code>Scheduler</code>提供的方法<code>runWithPriority</code>。</p>
<p>该方法接收一个<strong>优先级</strong>常量与一个<strong>回调函数</strong>作为参数。回调函数会以<strong>优先级</strong>高低为顺序排列在一个<strong>定时器</strong>中并在合适的时间触发。</p>
<p>对于更新来讲，传递的<strong>回调函数</strong>一般为状态更新流程概览一节讲到的<code>render阶段</code>的入口函数。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217">==unstable_runWithPriority==
这里</a>看到<code>runWithPriority</code>方法的定义。在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js">这里</a>看到<code>Scheduler</code>对优先级常量的定义。</p>
</blockquote>
<h4 id="例子-2">例子</h4>
<p>优先级最终会反映到<code>update.lane</code>变量上。当前我们只需要知道这个变量能够区分<code>Update</code>的优先级。</p>
<p>接下来我们通过一个例子结合上一节介绍的<code>Update</code>相关字段讲解优先级如何决定更新的顺序。</p>
<blockquote>
<p>该例子来自<a
target="_blank" rel="noopener" href="https://twitter.com/acdlite/status/978412930973687808">React Core
Team Andrew 向网友讲解 Update 工作流程的推文</a></p>
</blockquote>
<figure>
<img src="/img/web/react-19.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
Update 工作流程
</figcaption>
</figure>
<p>在这个例子中，有两个<code>Update</code>。我们将“关闭黑夜模式”产生的<code>Update</code>称为<code>u1</code>，输入字母“I”产生的<code>Update</code>称为<code>u2</code>。</p>
<p>其中<code>u1</code>先触发并进入<code>render阶段</code>。其优先级较低，执行时间较长。此时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span> = &#123;</span><br><span class="line">  <span class="attr">baseState</span>: &#123;</span><br><span class="line">    <span class="attr">blackTheme</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;H&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">firstBaseUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lastBaseUpdate</span>: <span class="literal">null</span></span><br><span class="line">  <span class="attr">shared</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: u1</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">effects</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>u1</code>完成<code>render阶段</code>前用户通过键盘输入字母“I”，产生了<code>u2</code>。<code>u2</code>属于<strong>受控的用户输入</strong>，优先级高于<code>u1</code>，于是中断<code>u1</code>产生的<code>render阶段</code>。</p>
<p>此时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span>.<span class="property">shared</span>.<span class="property">pending</span> === u2 ----&gt; u1</span><br><span class="line">                                     ^        |</span><br><span class="line">                                     |________|</span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line">u2.<span class="property">next</span> === u1;</span><br><span class="line">u1.<span class="property">next</span> === u2;</span><br></pre></td></tr></table></figure>
<p>其中<code>u2</code>优先级高于<code>u1</code>。</p>
<p>接下来进入<code>u2</code>产生的<code>render阶段</code>。</p>
<p>在<code>processUpdateQueue</code>方法中，<code>shared.pending</code>环状链表会被剪开并拼接在<code>baseUpdate</code>后面。</p>
<p>需要明确一点，<code>shared.pending</code>指向最后一个<code>pending</code>的<code>update</code>，所以实际执行时<code>update</code>的顺序为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u1 -- u2</span><br></pre></td></tr></table></figure>
<p>接下来遍历<code>baseUpdate</code>，处理优先级合适的<code>Update</code>（这一次处理的是更高优的<code>u2</code>）。</p>
<p>由于<code>u2</code>不是<code>baseUpdate</code>中的第一个<code>update</code>，在其之前的<code>u1</code>由于优先级不够被跳过。</p>
<p><code>update</code>之间可能有依赖关系，所以被跳过的<code>update</code>及其后面所有<code>update</code>会成为下次更新的<code>baseUpdate</code>。（即<code>u1 -- u2</code>）。</p>
<p>最终<code>u2</code>完成<code>render - commit阶段</code>。</p>
<p>此时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span> = &#123;</span><br><span class="line">  <span class="attr">baseState</span>: &#123;</span><br><span class="line">    <span class="attr">blackTheme</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;HI&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">firstBaseUpdate</span>: u1,</span><br><span class="line">  <span class="attr">lastBaseUpdate</span>: u2</span><br><span class="line">  <span class="attr">shared</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">effects</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>commit阶段</code>结尾会再调度一次更新。在该次更新中会基于<code>baseState</code>中<code>firstBaseUpdate</code>保存的<code>u1</code>，开启一次新的<code>render阶段</code>。</p>
<p>最终两次<code>Update</code>都完成后的结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fiber.<span class="property">updateQueue</span> = &#123;</span><br><span class="line">  <span class="attr">baseState</span>: &#123;</span><br><span class="line">    <span class="attr">blackTheme</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;HI&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">firstBaseUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lastBaseUpdate</span>: <span class="literal">null</span></span><br><span class="line">  <span class="attr">shared</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">effects</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看见，<code>u2</code>对应的更新执行了两次，相应的<code>render阶段</code>的生命周期勾子<code>componentWillXXX</code>也会触发两次。这也是为什么这些勾子会被标记为<code>unsafe_</code>。</p>
<h4 id="如何保证状态正确">如何保证状态正确</h4>
<p>现在我们基本掌握了<code>updateQueue</code>的工作流程。还有两个疑问：</p>
<p>-<code>render阶段</code>可能被中断。如何保证<code>updateQueue</code>中保存的<code>Update</code>不丢失？
-
有时候当前<strong>状态</strong>需要依赖前一个<strong>状态</strong>。如何在支持跳过<strong>低优先级状态</strong>的同时保证<strong>状态依赖的连续性</strong>？</p>
<p>我们分别讲解下。</p>
<h5 id="如何保证update不丢失">如何保证Update不丢失</h5>
<p>在上一节例子中我们讲到，在<code>render阶段</code>，<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面。</p>
<p>实际上<code>shared.pending</code>会被同时连接在<code>workInProgress updateQueue.lastBaseUpdate</code>与<code>current updateQueue.lastBaseUpdate</code>后面。</p>
<blockquote>
<p>具体代码见<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424">这里</a></p>
</blockquote>
<p>当<code>render阶段</code>被中断后重新开始时，会基于<code>current updateQueue</code>克隆出<code>workInProgress updateQueue</code>。由于<code>current updateQueue.lastBaseUpdate</code>已经保存了上一次的<code>Update</code>，所以不会丢失。</p>
<p>当<code>commit阶段</code>完成渲染，由于<code>workInProgress updateQueue.lastBaseUpdate</code>中保存了上一次的<code>Update</code>，所以
<code>workInProgress Fiber树</code>变成<code>current Fiber树</code>后也不会造成<code>Update</code>丢失。</p>
<h5 id="如何保证状态依赖的连续性">如何保证状态依赖的连续性</h5>
<p>当某个<code>Update</code>由于优先级低而被跳过时，保存在<code>baseUpdate</code>中的不仅是该<code>Update</code>，还包括链表中该<code>Update</code>之后的所有<code>Update</code>。</p>
<p>考虑如下例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baseState</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">shared.<span class="property">pending</span>: <span class="variable constant_">A1</span> --&gt; <span class="variable constant_">B2</span> --&gt; <span class="variable constant_">C1</span> --&gt; <span class="variable constant_">D2</span></span><br></pre></td></tr></table></figure>
<p>其中<strong>字母</strong>代表该<code>Update</code>要在页面插入的字母，数字代表优先级，值越低优先级越高。</p>
<p>第一次<code>render</code>，优先级为 1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baseState</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attr">baseUpdate</span>: <span class="literal">null</span>;</span><br><span class="line">render阶段使用的<span class="title class_">Update</span>: [<span class="variable constant_">A1</span>, <span class="variable constant_">C1</span>];</span><br><span class="line"><span class="attr">memoizedState</span>: <span class="string">&quot;AC&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>B2</code>由于优先级为
2，低于当前优先级，所以他及其后面的所有<code>Update</code>会被保存在<code>baseUpdate</code>中作为下次更新的<code>Update</code>（即<code>B2 C1 D2</code>）。</p>
<p>这么做是为了保持<strong>状态</strong>的前后依赖顺序。</p>
<p>第二次<code>render</code>，优先级为 2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baseState</span>: <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="attr">baseUpdate</span>: <span class="variable constant_">B2</span>-- &gt; <span class="variable constant_">C1</span>-- &gt; <span class="variable constant_">D2</span>;</span><br><span class="line">render阶段使用的<span class="title class_">Update</span>: [<span class="variable constant_">B2</span>, <span class="variable constant_">C1</span>, <span class="variable constant_">D2</span>];</span><br><span class="line"><span class="attr">memoizedState</span>: <span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>注意这里<code>baseState</code>并不是上一次更新的<code>memoizedState</code>。这是由于<code>B2</code>被跳过了。</p>
<p>即当有<code>Update</code>被跳过时，下次更新的<code>baseState !==</code>
上次更新的<code>memoizedState</code>。</p>
<blockquote>
<p>跳过<code>B2</code>的逻辑见<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479">这里</a></p>
</blockquote>
<p>通过以上例子我们可以发现，<code>React</code>保证最终的状态一定和用户触发的<strong>交互</strong>一致，但是中间过程<strong>状态</strong>可能由于设备不同而不同。</p>
<p>高优先级任务打断低优先级任务 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/dawn-river-wgn5n?file=/src/App.js">Demo</a></p>
<h4 id="参考资料-10">参考资料</h4>
<p><a
target="_blank" rel="noopener" href="https://juejin.im/post/5f05a3e25188252e5c576cdb">深入源码剖析
componentWillXXX 为什么 UNSAFE</a></p>
<p><a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L10">React
源码中讲解 Update 工作流程及优先级的注释</a></p>
<p><a target="_blank" rel="noopener" href="https://twitter.com/acdlite/status/978412930973687808">React
Core Team Andrew 向网友讲解 Update 工作流程的推文</a></p>
<h3 id="reactdom.render">ReactDOM.render</h3>
<p>经过五章的学习，我们终于回到了<code>React</code>应用的起点。</p>
<p>这一节我们完整的走通<code>ReactDOM.render</code>完成页面渲染的整个流程。</p>
<h4 id="创建fiber">创建fiber</h4>
<p>从双缓存机制一节我们知道，首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是要渲染组件所在组件树的根节点。</p>
<p>这一步发生在调用<code>ReactDOM.render</code>后进入的<code>legacyRenderSubtreeIntoContainer</code>方法中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container指ReactDOM.render的第二个参数（即应用挂载的DOM节点）</span></span><br><span class="line">root = container.<span class="property">_reactRootContainer</span> = <span class="title function_">legacyCreateRootFromDOMContainer</span>(</span><br><span class="line">  container,</span><br><span class="line">  forceHydrate,</span><br><span class="line">);</span><br><span class="line">fiberRoot = root.<span class="property">_internalRoot</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193">这里</a>看到这一步的代码</p>
</blockquote>
<p><code>legacyCreateRootFromDOMContainer</code>方法内部会调用<code>createFiberRoot</code>方法完成<code>fiberRootNode</code>和<code>rootFiber</code>的创建以及关联。并初始化<code>updateQueue</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">  containerInfo: any,</span></span><br><span class="line"><span class="params">  tag: RootTag,</span></span><br><span class="line"><span class="params">  hydrate: boolean,</span></span><br><span class="line"><span class="params">  hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line">  <span class="comment">// 创建fiberRootNode</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">root</span>: <span class="title class_">FiberRoot</span> = (<span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo, tag, hydrate): any);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接rootFiber与fiberRootNode</span></span><br><span class="line">  root.<span class="property">current</span> = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.<span class="property">stateNode</span> = root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化updateQueue</span></span><br><span class="line">  <span class="title function_">initializeUpdateQueue</span>(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上代码，现在我们可以在双缓存机制一节基础上补充上<code>rootFiber</code>到<code>fiberRootNode</code>的引用。</p>
<figure>
<img src="/img/web/react-20.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
rootFiber到fiberRootNode的引用
</figcaption>
</figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberRoot.new.js#L97">这里</a>看到这一步的代码</p>
</blockquote>
<h4 id="创建update">创建update</h4>
<p>我们已经做好了组件的初始化工作，接下来就等待创建<code>Update</code>来开启一次更新。</p>
<p>这一步发生在<code>updateContainer</code>方法中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  element: ReactNodeList,</span></span><br><span class="line"><span class="params">  container: OpaqueRoot,</span></span><br><span class="line"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Lane</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略与逻辑不相关代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(eventTime, lane, suspenseConfig);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// update.payload为需要挂载在根节点的组件</span></span><br><span class="line">  update.<span class="property">payload</span> = &#123;element&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callback为ReactDOM.render的第三个参数 —— 回调函数</span></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">callback</span> = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将生成的update加入updateQueue</span></span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(current, update);</span><br><span class="line">  <span class="comment">// 调度更新</span></span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(current, lane, eventTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略与逻辑不相关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255">这里</a>看到<code>updateContainer</code>的代码</p>
</blockquote>
<p>值得注意的是其中<code>update.payload = &#123;element&#125;;</code></p>
<p>这就是我们在<code>Update</code>一节介绍的，对于<code>HostRoot</code>，<code>payload</code>为<code>ReactDOM.render</code>的第一个传参。</p>
<h4 id="流程概览-4">流程概览</h4>
<p>至此，<code>ReactDOM.render</code>的流程就和我们已知的流程连接上了。</p>
<p>整个流程如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">创建fiberRootNode、rootFiber、updateQueue（<span class="string">`legacyCreateRootFromDOMContainer`</span>）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">创建<span class="title class_">Update</span>对象（<span class="string">`updateContainer`</span>）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">从fiber到root（<span class="string">`markUpdateLaneFromFiberToRoot`</span>）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">调度更新（<span class="string">`ensureRootIsScheduled`</span>）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">render阶段（<span class="string">`performSyncWorkOnRoot`</span> 或 <span class="string">`performConcurrentWorkOnRoot`</span>）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">commit阶段（<span class="string">`commitRoot`</span>）</span><br></pre></td></tr></table></figure>
<h4 id="react的其他入口函数">React的其他入口函数</h4>
<p>当前<code>React</code>共有三种模式：</p>
<ul>
<li><code>legacy</code>，这是当前<code>React</code>使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能。</li>
<li><code>blocking</code>，开启部分<code>concurrent</code>模式特性的中间模式。目前正在实验中。作为迁移到<code>concurrent</code>模式的第一个步骤。</li>
<li><code>concurrent</code>，面向未来的开发模式。我们之前讲的任务中断/任务优先级都是针对<code>concurrent</code>模式。</li>
</ul>
<p>你可以从下表看出各种模式对特性的支持：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>介绍</th>
<th>legacy 模式</th>
<th>blocking 模式</th>
<th>concurrent 模式</th>
</tr>
</thead>
<tbody>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs">String
Refs</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/legacy-context.html">Legacy
Context</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage">findDOMNode</a></td>
<td>✅</td>
<td>🚫**</td>
<td>🚫**</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly">Suspense</a></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist">SuspenseList</a></td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Suspense SSR + Hydration</td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Progressive Hydration</td>
<td>🚫</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Selective Hydration</td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>Cooperative Multitasking</td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td>Automatic batching of multiple setStates</td>
<td>🚫*</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state">Priority-based
Rendering</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering">Interruptible
Prerendering</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions">useTransition</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value">useDeferredValue</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
<tr>
<td><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train">Suspense
Reveal "Train"</a></td>
<td>🚫</td>
<td>🚫</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><code>*</code>：<code>legacy</code>模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非<code>React</code>事件想使用这个功能必须使用
<code>unstable_batchedUpdates</code>。在<code>blocking</code>模式和<code>concurrent</code>模式下，所有的<code>setState</code>在默认情况下都是批处理的。</p>
<p><code>**</code>：会在开发中发出警告。</p>
<p>模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式。</p>
<p>基于此原因，可以通过不同的<strong>入口函数</strong>开启不同模式：</p>
<ul>
<li><code>legacy -- ReactDOM.render(&lt;App /&gt;, rootNode)</code></li>
<li><code>blocking -- ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>
<li><code>concurrent -- ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes">这里</a>看到<code>React</code>团队解释为什么会有这么多模式</p>
</blockquote>
<p>虽然不同模式的<strong>入口函数</strong>不同，但是他们仅对<code>fiber.mode</code>变量产生影响，对我们在<a
target="_blank" rel="noopener" href="https://react.iamkasong.com/state/reactdom.html#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88">流程概览</a>中描述的流程并无影响。</p>
<h3 id="this.setstate">this.setState</h3>
<p>当我们有了前面知识的铺垫，就很容易理解<code>this.setState</code>的工作流程。</p>
<h4 id="流程概览-5">流程概览</h4>
<p>可以看到，<code>this.setState</code>内会调用<code>this.updater.enqueueSetState</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span> (<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">typeof</span> partialState === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> partialState === <span class="string">&#x27;function&#x27;</span> || partialState == <span class="literal">null</span>)) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>( <span class="string">&quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57">这里</a>看到这段代码</p>
</blockquote>
<p>在<code>enqueueSetState</code>方法中就是我们熟悉的从创建<code>update</code>到调度<code>update</code>的流程了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueSetState</span>(<span class="params">inst, payload, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过组件实例获取对应fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">  <span class="keyword">const</span> suspenseConfig = <span class="title function_">requestCurrentSuspenseConfig</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber, suspenseConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(eventTime, lane, suspenseConfig);</span><br><span class="line"></span><br><span class="line">  update.<span class="property">payload</span> = payload;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值回调函数</span></span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">callback</span> = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将update插入updateQueue</span></span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">  <span class="comment">// 调度update</span></span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L196">这里</a>看到<code>enqueueSetState</code>代码</p>
</blockquote>
<p>这里值得注意的是对于<code>ClassComponent</code>，<code>update.payload</code>为<code>this.setState</code>的第一个传参（即要改变的<code>state</code>）。</p>
<h4 id="this.forceupdate">this.forceUpdate</h4>
<p>在<code>this.updater</code>上，除了<code>enqueueSetState</code>外，还存在<code>enqueueForceUpdate</code>，当我们调用<code>this.forceUpdate</code>时会调用他。</p>
<p>可以看到，除了赋值<code>update.tag = ForceUpdate;</code>以及没有<code>payload</code>外，其他逻辑与<code>this.setState</code>一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueForceUpdate</span>(<span class="params">inst, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">    <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">    <span class="keyword">const</span> suspenseConfig = <span class="title function_">requestCurrentSuspenseConfig</span>();</span><br><span class="line">    <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber, suspenseConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(eventTime, lane, suspenseConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值tag为ForceUpdate</span></span><br><span class="line">    update.<span class="property">tag</span> = <span class="title class_">ForceUpdate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.<span class="property">callback</span> = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L260">这里</a>看到<code>enqueueForceUpdate</code>代码</p>
</blockquote>
<p>那么赋值<code>update.tag = ForceUpdate;</code>有何作用呢？</p>
<p>在判断<code>ClassComponent</code>是否需要更新时有两个条件需要满足：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldUpdate =</span><br><span class="line"> <span class="title function_">checkHasForceUpdateAfterProcessing</span>() ||</span><br><span class="line"> <span class="title function_">checkShouldComponentUpdate</span>(</span><br><span class="line">   workInProgress,</span><br><span class="line">   ctor,</span><br><span class="line">   oldProps,</span><br><span class="line">   newProps,</span><br><span class="line">   oldState,</span><br><span class="line">   newState,</span><br><span class="line">   nextContext,</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L1137">这里</a>看到这段代码</p>
</blockquote>
<ul>
<li><code>checkHasForceUpdateAfterProcessing</code>：内部会判断本次更新的<code>Update</code>是否为<code>ForceUpdate</code>。即如果本次更新的<code>Update</code>中存在<code>tag</code>为<code>ForceUpdate</code>，则返回<code>true</code>。</li>
<li><code>checkShouldComponentUpdate</code>：内部会调用<code>shouldComponentUpdate</code>方法。以及当该<code>ClassComponent</code>为<code>PureComponent</code>时会浅比较<code>state</code>与<code>props</code>。</li>
</ul>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L294">这里</a>看到<code>checkShouldComponentUpdate</code>代码</p>
</blockquote>
<p>所以，当某次更新含有<code>tag</code>为<code>ForceUpdate</code>的<code>Update</code>，那么当前<code>ClassComponent</code>不会受其他<strong>性能优化手段</strong>（<code>shouldComponentUpdate|PureComponent</code>）影响，一定会更新。</p>
<h4 id="总结-11">总结</h4>
<p>至此，我们学习完了<code>HostRoot</code> |
<code>ClassComponent</code>所使用的<code>Update</code>的更新流程。</p>
<p>在下一章我们会学习另一种数据结构的<code>Update</code> ——
用于<code>Hooks</code>的<code>Update</code>。</p>
<h2 id="第七章-hooks">第七章 Hooks</h2>
<h3 id="hooks理念">Hooks理念</h3>
<blockquote>
<p>在开始本章学习前，你需要了解<code>Hooks</code>的基本用法。
如果你还未使用过<code>Hooks</code>，可以从<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html">官方文档</a>开始。</p>
</blockquote>
<p>你可以从这里了解<code>Hooks</code>的设计动机。作为一名框架使用者，了解设计动机对于我们日常开发就足够了。</p>
<p>但是，为了更好的理解<code>Hooks</code>的源码架构，我们需要转换身份，以框架开发者的角度来看待<code>Hooks</code>的设计理念。</p>
<h4 id="从logo聊起">从LOGO聊起</h4>
<figure>
<img src="/img/web/react-21.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
LOGO
</figcaption>
</figure>
<p><code>React LOGO</code>的图案是代表原子（<code>atom</code>）的符号。世间万物由原子组成，原子的类型与属性决定了事物的外观与表现。</p>
<p>同样，在<code>React</code>中，我们可以将UI拆分为很多独立的单元，每个单元被称为<code>Component</code>。这些<code>Component</code>的属性与类型决定了<code>UI</code>的外观与表现。</p>
<p>讽刺的是，原子在希腊语中的意思为不可分割的（<code>indivisible</code>），但随后科学家在原子中发现了更小的粒子
——
电子（<code>electron</code>）。电子可以很好的解释原子是如何工作的。</p>
<p>在<code>React</code>中，我们可以说<code>ClassComponent</code>是一类原子。</p>
<p>但对于<code>Hooks</code>来说，与其说是一类原子，不如说他是更贴近事物运行规律的电子。</p>
<p>我们知道，<code>React</code>的架构遵循<code>schedule - render - commit</code>的运行流程，这个流程是<code>React</code>世界最底层的运行规律。</p>
<p><code>ClassComponent</code>作为<code>React</code>世界的原子，他的生命周期（<code>componentWillXXX/componentDidXXX</code>）是为了介入<code>React</code>的运行流程而实现的更上层抽象，这么做是为了方便框架使用者更容易上手。</p>
<p>相比于<code>ClassComponent</code>的更上层抽象，<code>Hooks</code>则更贴近<code>React</code>内部运行的各种概念（<code>state</code>
| <code>context</code> | <code>life-cycle</code>）。</p>
<p>作为使用<code>React</code>技术栈的开发者，当我们初次学习<code>Hooks</code>时，不管是官方文档还是身边有经验的同事，总会拿<code>ClassComponent</code>的生命周期来类比<code>Hooks API</code>的执行时机。</p>
<p>这固然是很好的上手方式，但是当我们熟练运用<code>Hooks</code>时，就会发现，这两者的概念有很多割裂感，并不是同一抽象层次可以互相替代的概念。</p>
<p>比如：替代<code>componentWillReceiveProps</code>的<code>Hooks</code>是什么呢？</p>
<p>可能有些同学会回答，是<code>useEffect</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;something updated&#x27;</span>);</span><br><span class="line"> &#125;, [props.<span class="property">something</span>])</span><br></pre></td></tr></table></figure>
<p>但是<code>componentWillReceiveProps</code>是在<code>render</code>阶段执行，而<code>useEffect</code>是在<code>commit阶段</code>完成渲染后异步执行。</p>
<blockquote>
<p>这篇文章可以帮你更好理解<code>componentWillReceiveProps</code>：<a
target="_blank" rel="noopener" href="https://juejin.im/post/5f05a3e25188252e5c576cdb">深入源码剖析componentWillXXX为什么UNSAFE</a></p>
</blockquote>
<p>所以，从源码运行规律的角度看待<code>Hooks</code>，可能是更好的角度。这也是为什么上文说<code>Hooks</code>是<code>React</code>世界的<strong>电子</strong>而不是<strong>原子</strong>的原因。</p>
<blockquote>
<p>以上见解参考自<a
target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;feature=youtu.be">React
Core Team Dan在 React Conf2018的演讲</a></p>
</blockquote>
<h4 id="总结-12">总结</h4>
<p><code>Concurrent Mode</code>是<code>React</code>未来的发展方向，而<code>Hooks</code>是能够最大限度发挥<code>Concurrent Mode</code>潜力的<code>Component</code>构建方式。</p>
<p>正如<code>Dan</code>在<code>React Conf 2018</code>演讲结尾所说：你可以从<code>React</code>的<code>LOGO</code>中看到这些围绕着核心的电子飞行轨道，<code>Hooks</code>可能一直就在其中。</p>
<h3 id="极简hooks实现">极简Hooks实现</h3>
<p>为了更好理解<code>Hooks</code>原理，这一节我们遵循React的运行流程，实现一个不到
100
行代码的极简<code>useState Hook</code>。建议对照着代码来看本节内容。</p>
<h4 id="工作原理">工作原理</h4>
<p>对于<code>useState Hook</code>，考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将工作分为两部分：</p>
<ol type="1">
<li>通过一些途径产生<strong>更新</strong>，<strong>更新</strong>会造成组件<code>render</code>。</li>
<li>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</li>
</ol>
<p>其中<strong>步骤1</strong>的<strong>更新</strong>可以分为<code>mount</code>和<code>update</code>：</p>
<ol type="1">
<li>调用<code>ReactDOM.render</code>会产生<code>mount</code>的更新，更新内容为<code>useState</code>的<code>initialValue</code>（即0）。</li>
<li>点击<code>p</code>标签触发<code>updateNum会产生一次``update</code>的更新，更新内容为<code>num =&gt; num + 1</code>。</li>
</ol>
<p>接下来讲解这两个步骤如何实现。</p>
<h4 id="更新是什么">更新是什么</h4>
<blockquote>
<p>通过一些途径产生更新，更新会造成组件<code>render</code>。</p>
</blockquote>
<p>首先我们要明确<strong>更新</strong>是什么。</p>
<p>在我们的极简例子中，<strong>更新</strong>就是如下数据结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = &#123;</span><br><span class="line">  <span class="comment">// 更新执行的函数</span></span><br><span class="line">  action,</span><br><span class="line">  <span class="comment">// 与同一个Hook的其他更新形成链表</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于<code>App</code>来说，点击<code>p</code>标签产生的<code>update</code>的<code>action</code>为<code>num =&gt; num + 1</code>。</p>
<p>如果我们改写下<code>App</code>的<code>onClick</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      updateNum((num) =&gt; num + 1);</span></span><br><span class="line"><span class="language-xml">      updateNum((num) =&gt; num + 1);</span></span><br><span class="line"><span class="language-xml">      updateNum((num) =&gt; num + 1);</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  &gt;</span></span><br><span class="line"><span class="language-xml">    &#123;num&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>那么点击<code>p</code>标签会产生三个<code>update</code>。</p>
<h4 id="update-数据结构">update 数据结构</h4>
<p>这些<code>update</code>是如何组合在一起呢？</p>
<p>答案是：他们会形成<strong>环状单向链表</strong>。</p>
<p>调用<code>updateNum</code>实际调用的是<code>dispatchAction.bind(null, hook.queue)</code>，我们先来了解下这个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">queue, action</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = &#123;</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环状单向链表操作</span></span><br><span class="line">  <span class="keyword">if</span> (queue.<span class="property">pending</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">next</span> = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.<span class="property">next</span> = queue.<span class="property">pending</span>.<span class="property">next</span>;</span><br><span class="line">    queue.<span class="property">pending</span>.<span class="property">next</span> = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="property">pending</span> = update;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟React开始调度更新</span></span><br><span class="line">  <span class="title function_">schedule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环状链表操作不太容易理解，这里我们详细讲解下。</p>
<p>当产生第一个<code>update</code>（我们叫他<code>u0</code>），此时<code>queue.pending === null</code>。</p>
<p><code>update.next = update;</code>即<code>u0.next = u0</code>，他会和自己首尾相连形成单向环状链表。</p>
<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u0</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="property">pending</span> = u0 ---&gt; u0</span><br><span class="line">                ^       |</span><br><span class="line">                |       |</span><br><span class="line">                ---------</span><br></pre></td></tr></table></figure>
<p>当产生第二个<code>update</code>（我们叫他<code>u1</code>），<code>update.next = queue.pending.next;</code>，此时<code>queue.pending.next === u0</code>，
即<code>u1.next = u0</code>。</p>
<p><code>queue.pending.next = update;</code>，即<code>u0.next = u1</code>。</p>
<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u1</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="property">pending</span> = u1 ---&gt; u0</span><br><span class="line">                ^       |</span><br><span class="line">                |       |</span><br><span class="line">                ---------</span><br></pre></td></tr></table></figure>
<p>你可以照着这个例子模拟插入多个<code>update</code>的情况，会发现<code>queue.pending</code>始终指向最后一个插入的<code>update</code>。</p>
<p>这样做的好处是，当我们要遍历<code>update</code>时，<code>queue.pending.next</code>指向第一个插入的<code>update</code>。</p>
<h4 id="状态如何保存">状态如何保存</h4>
<p>现在我们知道，<strong>更新</strong>产生的<code>update</code>对象会保存在<code>queue</code>中。</p>
<p>不同于<code>ClassComponent</code>的实例可以存储数据，对于<code>FunctionComponent</code>，<code>queue</code>存储在哪里呢？</p>
<p>答案是：<code>FunctionComponent</code>对应的<code>fiber</code>中。</p>
<p>我们使用如下精简的<code>fiber</code>结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App组件对应的fiber对象</span></span><br><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">  <span class="comment">// 保存该FunctionComponent对应的Hooks链表</span></span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向App函数</span></span><br><span class="line">  <span class="attr">stateNode</span>: <span class="title class_">App</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hook-数据结构">Hook 数据结构</h4>
<p>接下来我们关注<code>fiber.memoizedState</code>中保存的<code>Hook</code>的数据结构。</p>
<p>可以看到，<code>Hook</code>与<code>update</code>类似，都通过链表连接。不过<code>Hook</code>是无环的单向链表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hook = &#123;</span><br><span class="line">  <span class="comment">// 保存update的queue，即上文介绍的queue</span></span><br><span class="line">  <span class="attr">queue</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 保存hook对应的state</span></span><br><span class="line">  <span class="attr">memoizedState</span>: initialState,</span><br><span class="line">  <span class="comment">// 与下一个Hook连接形成单向无环链表</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 注意区分<code>update</code>与<code>hook</code>的所属关系：
每个<code>useState</code>对应一个<code>hook</code>对象。
调用<code>const [num, updateNum] = useState(0);</code>时<code>updateNum</code>（即上文介绍的<code>dispatchAction</code>）产生的<code>update</code>保存在<code>useState</code>对应的<code>hook.queue</code>中。</p>
</blockquote>
<h4 id="模拟-react-调度更新流程">模拟 React 调度更新流程</h4>
<p>在上文<code>dispatchAction</code>末尾我们通过<code>schedule</code>方法模拟<code>React</code>调度更新流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">queue, action</span>) &#123;</span><br><span class="line">  <span class="comment">// ...创建update</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...环状单向链表操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟React开始调度更新</span></span><br><span class="line">  <span class="title function_">schedule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来实现他。</p>
<p>我们用<code>isMount</code>变量指代是<code>mount</code>还是<code>update</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次render时是mount</span></span><br><span class="line">isMount = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">schedule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 更新前将workInProgressHook重置为fiber保存的第一个Hook</span></span><br><span class="line">  workInProgressHook = fiber.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="comment">// 触发组件render</span></span><br><span class="line">  fiber.<span class="title function_">stateNode</span>();</span><br><span class="line">  <span class="comment">// 组件首次render为mount，以后再触发的更新为update</span></span><br><span class="line">  isMount = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>workInProgressHook</code>变量指向当前正在工作的<code>hook</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressHook = fiber.<span class="property">memoizedState</span>;</span><br></pre></td></tr></table></figure>
<p>在组件<code>render</code>时，每当遇到下一个<code>useState</code>，我们移动<code>workInProgressHook</code>的指针。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br></pre></td></tr></table></figure>
<p>这样，只要每次组件<code>render</code>时<code>useState</code>的调用顺序及数量保持一致，那么始终可以通过<code>workInProgressHook</code>找到当前<code>useState</code>对应的<code>hook</code>对象。</p>
<p>到此为止，我们已经完成第一步。</p>
<ol type="1">
<li>通过一些途径产生更新，更新会造成组件<code>render</code>。</li>
</ol>
<p>接下来实现第二步。</p>
<ol start="2" type="1">
<li>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</li>
</ol>
<h4 id="计算-state">计算 state</h4>
<p>组件<code>render</code>时会调用<code>useState</code>，他的大体逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前useState使用的hook会被赋值该该变量</span></span><br><span class="line">  <span class="keyword">let</span> hook;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMount) &#123;</span><br><span class="line">    <span class="comment">// ...mount时需要生成hook对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...update时从workInProgressHook中取出该useState对应的hook</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> baseState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (hook.<span class="property">queue</span>.<span class="property">pending</span>) &#123;</span><br><span class="line">    <span class="comment">// ...根据queue.pending中保存的update更新state</span></span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = baseState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [baseState, dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, hook.<span class="property">queue</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先关注如何获取<code>hook</code>对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isMount) &#123;</span><br><span class="line">  <span class="comment">// mount时为该useState生成hook</span></span><br><span class="line">  hook = &#123;</span><br><span class="line">    <span class="attr">queue</span>: &#123;</span><br><span class="line">      <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">memoizedState</span>: initialState,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将hook插入fiber.memoizedState链表末尾</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">memoizedState</span>) &#123;</span><br><span class="line">    fiber.<span class="property">memoizedState</span> = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移动workInProgressHook指针</span></span><br><span class="line">  workInProgressHook = hook;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// update时找到对应hook</span></span><br><span class="line">  hook = workInProgressHook;</span><br><span class="line">  <span class="comment">// 移动workInProgressHook指针</span></span><br><span class="line">  workInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当找到该<code>useState</code>对应的<code>hook</code>后，如果该<code>hook.queue.pending</code>不为空（即存在<code>update</code>），则更新其<code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update执行前的初始state</span></span><br><span class="line"><span class="keyword">let</span> baseState = hook.<span class="property">memoizedState</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hook.<span class="property">queue</span>.<span class="property">pending</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取update环状单向链表中第一个update</span></span><br><span class="line">  <span class="keyword">let</span> firstUpdate = hook.<span class="property">queue</span>.<span class="property">pending</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 执行update action</span></span><br><span class="line">    <span class="keyword">const</span> action = firstUpdate.<span class="property">action</span>;</span><br><span class="line">    baseState = <span class="title function_">action</span>(baseState);</span><br><span class="line">    firstUpdate = firstUpdate.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个update执行完后跳出循环</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (firstUpdate !== hook.<span class="property">queue</span>.<span class="property">pending</span>.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空queue.pending</span></span><br><span class="line">  hook.<span class="property">queue</span>.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将update action执行完后的state作为memoizedState</span></span><br><span class="line">hook.<span class="property">memoizedState</span> = baseState;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hook;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMount) &#123;</span><br><span class="line">    hook = &#123;</span><br><span class="line">      <span class="attr">queue</span>: &#123;</span><br><span class="line">        <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">memoizedState</span>: initialState,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!fiber.<span class="property">memoizedState</span>) &#123;</span><br><span class="line">      fiber.<span class="property">memoizedState</span> = hook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">    &#125;</span><br><span class="line">    workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hook = workInProgressHook;</span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> baseState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (hook.<span class="property">queue</span>.<span class="property">pending</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> firstUpdate = hook.<span class="property">queue</span>.<span class="property">pending</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> action = firstUpdate.<span class="property">action</span>;</span><br><span class="line">      baseState = <span class="title function_">action</span>(baseState);</span><br><span class="line">      firstUpdate = firstUpdate.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (firstUpdate !== hook.<span class="property">queue</span>.<span class="property">pending</span>.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">    hook.<span class="property">queue</span>.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = baseState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [baseState, dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, hook.<span class="property">queue</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对触发事件进行抽象">对触发事件进行抽象</h4>
<p>最后，让我们抽象一下<code>React</code>的事件触发方式。</p>
<p>通过调用<code>App</code>返回的<code>click</code>方法模拟组件<code>click</code>的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;isMount ? <span class="string">&quot;mount&quot;</span> : <span class="string">&quot;update&quot;</span>&#125;</span> num: `</span>, num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">updateNum</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在线-demo">在线 Demo</h4>
<p>至此，我们完成了一个不到 100
行代码的<code>Hooks</code>。重要的是，他与<code>React</code>的运行逻辑相同。</p>
<p>精简 Hooks 的在线 <a
target="_blank" rel="noopener" href="https://code.h5jun.com/woniq/1/edit?js,console">Demo</a></p>
<p>调用<code>window.app.click()</code>模拟组件点击事件。</p>
<p>你也可以使用多个<code>useState</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [num1, updateNum1] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;isMount ? <span class="string">&quot;mount&quot;</span> : <span class="string">&quot;update&quot;</span>&#125;</span> num: `</span>, num);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;isMount ? <span class="string">&quot;mount&quot;</span> : <span class="string">&quot;update&quot;</span>&#125;</span> num1: `</span>, num1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">updateNum</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">focus</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">updateNum1</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="与-react-的区别">与 React 的区别</h4>
<p>我们用尽可能少的代码模拟了<code>Hooks</code>的运行，但是相比<code>React Hooks</code>，他还有很多不足。以下是他与<code>React Hooks</code>的区别：</p>
<ol type="1">
<li><code>React Hooks</code>没有使用<code>isMount</code>变量，而是在不同时机使用不同的<code>dispatcher</code>。换言之，<code>mount</code>时的<code>useState</code>与<code>update</code>时的<code>useState</code>不是同一个函数。</li>
<li><code>React Hooks</code>有中途跳过更新的优化手段。</li>
<li><code>React Hooks</code>有<code>batchedUpdates</code>，当在<code>click</code>中触发三次<code>updateNum</code>，精简<code>React</code>会触发三次更新，而<code>React</code>只会触发一次。</li>
<li><code>React Hooks</code>的<code>update</code>有优先级概念，可以跳过不高优先的<code>update</code>。</li>
</ol>
<p>更多的细节，我们会在本章后续小节讲解。</p>
<h3 id="hooks数据结构">Hooks数据结构</h3>
<p>在上一节我们实现了一个极简的<code>useState</code>，了解了<code>Hooks</code>的运行原理。</p>
<p>本节我们讲解<code>Hooks</code>的数据结构，为后面介绍具体的<code>hook</code>打下基础。</p>
<h4 id="dispatcher">dispatcher</h4>
<p>在上一节的极简<code>useState</code>实现中，使用<code>isMount</code>变量区分<code>mount</code>与<code>update</code>。</p>
<p>在真实的<code>Hooks</code>中，组件<code>mount</code>时的<code>hook</code>与<code>update</code>时的<code>hook</code>来源于不同的对象，这类对象在源码中被称为<code>dispatcher</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount时的Dispatcher</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">useCallback</span>: mountCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: mountImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: mountLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: mountMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: mountReducer,</span><br><span class="line">  <span class="attr">useRef</span>: mountRef,</span><br><span class="line">  <span class="attr">useState</span>: mountState,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update时的Dispatcher</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">useCallback</span>: updateCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: updateImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: updateMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: updateReducer,</span><br><span class="line">  <span class="attr">useRef</span>: updateRef,</span><br><span class="line">  <span class="attr">useState</span>: updateState,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见，<code>mount</code>时调用的<code>hook</code>和<code>update</code>时调用的<code>hook</code>其实是两个不同的函数。</p>
<p>在<code>FunctionComponent render</code>前，会根据<code>FunctionComponent</code>对应<code>fiber</code>的以下条件区分<code>mount</code>与<code>update</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>并将不同情况对应的<code>dispatcher</code>赋值给全局变量<code>ReactCurrentDispatcher</code>的<code>current</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =</span><br><span class="line">      current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">        ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">        : <span class="title class_">HooksDispatcherOnUpdate</span>;  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409">这里</a>看到这行代码</p>
</blockquote>
<p>在<code>FunctionComponent render</code>时，会从<code>ReactCurrentDispatcher.current</code>（即当前<code>dispatcher</code>）中寻找需要的<code>hook</code>。</p>
<p>换言之，不同的调用栈上下文为<code>ReactCurrentDispatcher.current</code>赋值不同的<code>dispatcher</code>，则<code>FunctionComponent render</code>时调用的<code>hook</code>也是不同的函数。</p>
<blockquote>
<p>除了这两个<code>dispatcher</code>，你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1775">这里</a>看到其他<code>dispatcher</code>定义</p>
</blockquote>
<h4 id="一个dispatcher使用场景">一个dispatcher使用场景</h4>
<p>当错误的书写了嵌套形式的<code>hook</code>，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时<code>ReactCurrentDispatcher.current</code>已经指向<code>ContextOnlyDispatcher</code>，所以调用<code>useState</code>实际会调用<code>throwInvalidHookError</code>，直接抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextOnlyDispatcher</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">useCallback</span>: throwInvalidHookError,</span><br><span class="line">  <span class="attr">useContext</span>: throwInvalidHookError,</span><br><span class="line">  <span class="attr">useEffect</span>: throwInvalidHookError,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: throwInvalidHookError,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: throwInvalidHookError,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458">这里</a>看到这段逻辑</p>
</blockquote>
<h4 id="hook的数据结构">Hook的数据结构</h4>
<p>接下来我们学习<code>hook</code>的数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L546">这里</a>看到创建<code>hook</code>的逻辑</p>
</blockquote>
<p>其中除<code>memoizedState</code>以外字段的意义与上一章介绍的<code>updateQueue</code>类似。</p>
<h4 id="memoizedstate">memoizedState</h4>
<blockquote>
<p><code>hook</code>与<code>FunctionComponent fiber</code>都存在<code>memoizedState</code>属性，不要混淆他们的概念。
<code>fiber.memoizedState</code>：<code>FunctionComponent</code>对应<code>fiber</code>保存的<code>Hooks</code>链表。
<code>hook.memoizedState</code>：<code>Hooks</code>链表中保存的单一<code>hook</code>对应的数据。</p>
</blockquote>
<p>不同类型<code>hook</code>的<code>memoizedState</code>保存不同类型数据，具体如下：</p>
<ul>
<li>useState：对于<code>const [state, updateState] = useState(initialState)</code>，<code>memoizedState</code>保存<code>state</code>的值</li>
<li>useReducer：对于<code>const [state, dispatch] = useReducer(reducer, &#123;&#125;);</code>，<code>memoizedState</code>保存<code>state</code>的值</li>
<li>useEffect：<code>memoizedState</code>保存包含<code>useEffect</code>回调函数、依赖项等的链表数据结构<code>effect</code>，你可以在这里看到<code>effect</code>的创建过程。<code>effect</code>链表同时会保存在<code>fiber.updateQueue</code>中</li>
<li>useRef：对于useRef(1)，memoizedState保存{current: 1}</li>
<li>useMemo：对于useMemo(callback,
[depA])，memoizedState保存[callback(), depA]</li>
<li>useCallback：对于<code>useCallback(callback, [depA])</code>，<code>memoizedState</code>保存<code>[callback, depA]</code>。与<code>useMemo</code>的区别是，<code>useCallback</code>保存的是<code>callback</code>函数本身，而<code>useMemo</code>保存的是<code>callback</code>函数的执行结果</li>
</ul>
<p>有些<code>hook</code>是没有<code>memoizedState</code>的，比如：</p>
<ul>
<li>useContext</li>
</ul>
<h3 id="usestate与usereducer">useState与useReducer</h3>
<p><code>Redux</code>的作者<code>Dan</code>加入<code>React</code>核心团队后的一大贡献就是“将Redux的理念带入React”。</p>
<p>这里面最显而易见的影响莫过于<code>useState</code>与<code>useReducer</code>这两个<code>Hook</code>。本质来说，<code>useState</code>只是预置了<code>reducer</code>的<code>useReducer</code>。</p>
<p>本节我们来学习<code>useState</code>与<code>useReducer</code>的实现。</p>
<h4 id="流程概览-6">流程概览</h4>
<p>我们将这两个<code>Hook</code>的工作流程分为<strong>声明阶段</strong>和<strong>调用阶段</strong>，对于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;a&quot; &#125;)&#125;&gt;&#123;state.a&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>声明阶段</strong>即<code>App</code>调用时，会依次执行<code>useReducer</code>与<code>useState</code>方法。</li>
<li><strong>调用阶段</strong>即点击按钮后，<code>dispatch</code>或<code>updateNum</code>被调用时。</li>
</ul>
<h4 id="声明阶段">声明阶段</h4>
<p>当<code>FunctionComponent</code>进入<code>render</code>阶段的<code>beginWork</code>时，会调用<code>renderWithHooks</code>方法。</p>
<p>该方法内部会执行<code>FunctionComponent</code>对应函数（即<code>fiber.type</code>）。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L415">这里</a>看到这段逻辑</p>
</blockquote>
<p>对于这两个<code>Hook</code>，他们的源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useReducer</span>(<span class="params">reducer, initialArg, init</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上一节dispatcher所说，在不同场景下，同一个<code>Hook</code>会调用不同处理函数。</p>
<p>我们分别讲解<code>mount</code>与<code>update</code>两个场景。</p>
<h5 id="mount-时-3">mount 时</h5>
<p><code>mount</code>时，<code>useReducer</code>会调用<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L638">mountReducer</a>，<code>useState</code>会调用<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1143">mountState</a>。</p>
<p>我们来简单对比这这两个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mountState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前的hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...赋值初始state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建queue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建dispatch</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前的hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...赋值初始state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建queue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建dispatch</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>mountWorkInProgressHook</code>方法会创建并返回对应<code>hook</code>，对应极简<code>Hooks</code>实现中<code>useState</code>方法的<code>isMount</code>逻辑部分。</p>
<p>可以看到，<code>mount</code>时这两个<code>Hook</code>的唯一区别为<code>queue</code>参数的<code>lastRenderedReducer</code>字段。</p>
<p><code>queue</code>的数据结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">  <span class="comment">// 与极简实现中的同名字段意义相同，保存update对象</span></span><br><span class="line">  <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 保存dispatchAction.bind()的值</span></span><br><span class="line">  <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次render时使用的reducer</span></span><br><span class="line">  <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">  <span class="comment">// 上一次render时的state</span></span><br><span class="line">  <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中，<code>useReducer</code>的<code>lastRenderedReducer</code>为传入的<code>reducer</code>参数。<code>useState</code>的<code>lastRenderedReducer``为basicStateReducer</code>。</p>
<p><code>basicStateReducer</code>方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> basicStateReducer&lt;S&gt;(<span class="attr">state</span>: S, <span class="attr">action</span>: <span class="title class_">BasicStateAction</span>&lt;S&gt;): S &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span> ? <span class="title function_">action</span>(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>useState</code>即<code>reducer</code>参数为<code>basicStateReducer</code>的<code>useReducer</code>。</p>
<p><code>mount</code>时的整体运行逻辑与极简实现的<code>isMount</code>逻辑类似，你可以对照着看。</p>
<h5 id="update-时-3">update 时</h5>
<p>如果说<code>mount</code>时这两者还有区别，那<code>update</code>时，<code>useReducer</code>与<code>useState</code>调用的则是同一个函数<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665">updateReducer</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 获取当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line"></span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...同update与updateQueue类似的更新逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span>: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程可以概括为一句话：</p>
<blockquote>
<p>找到对应的<code>hook</code>，根据<code>update</code>计算该<code>hook</code>的新<code>state</code>并返回。</p>
</blockquote>
<p><code>mount</code>时获取当前<code>hook</code>使用的是<code>mountWorkInProgressHook</code>，而<code>update</code>时使用的是<code>updateWorkInProgressHook</code>，这里的原因是：</p>
<ul>
<li><code>mount</code>时可以确定是调用<code>ReactDOM.render</code>或相关初始化<code>API</code>产生的更新，只会执行一次。</li>
<li><code>update</code>可能是在事件回调或副作用中触发的更新或者是<code>render阶段</code>触发的更新，为了避免组件无限循环更新，后者需要区别对待。</li>
</ul>
<p>举个<code>render阶段</code>触发的<strong>更新</strong>的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">updateNum</span>(num + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>App</code>调用时，代表已经进入<code>render阶段</code>执行<code>renderWithHooks</code>。</p>
<p>在<code>App</code>内部，调用<code>updateNum</code>会触发一次更新。如果不对这种情况下触发的更新作出限制，那么这次更新会开启一次新的<code>render阶段</code>，最终会无限循环更新。</p>
<p>基于这个原因，<code>React</code>用一个标记变量<code>didScheduleRenderPhaseUpdate</code>判断是否是<code>render阶段</code>触发的更新。</p>
<p><code>updateWorkInProgressHook</code>方法也会区分这两种情况来获取对应<code>hook</code>。</p>
<p>获取对应<code>hook</code>，接下来会根据<code>hook</code>中保存的<code>state</code>计算新的<code>state</code>，这个步骤同<code>Update</code>
一节一致。</p>
<h4 id="调用阶段">调用阶段</h4>
<p>调用阶段会执行<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1662">dispatchAction</a>，此时该<code>FunctionComponent</code>对应的<code>fiber</code>以及<code>hook.queue</code>已经通过调用<code>bind</code>方法预先作为参数传入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>) &#123;</span><br><span class="line">  <span class="comment">// ...创建update</span></span><br><span class="line">  <span class="keyword">var</span> update = &#123;</span><br><span class="line">    <span class="attr">eventTime</span>: eventTime,</span><br><span class="line">    <span class="attr">lane</span>: lane,</span><br><span class="line">    <span class="attr">suspenseConfig</span>: suspenseConfig,</span><br><span class="line">    <span class="attr">action</span>: action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...将update加入queue.pending</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> alternate = fiber.<span class="property">alternate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber$1 ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$1)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// render阶段触发的更新</span></span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass =</span><br><span class="line">      didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp;</span><br><span class="line">      (alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ...fiber的updateQueue为空，优化路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程可以概括为：</p>
<blockquote>
<p>创建<code>update``，将update</code>加入<code>queue.pending</code>中，并开启调度。</p>
</blockquote>
<p>这里值得注意的是<code>if...else...</code>逻辑，其中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fiber === currentlyRenderingFiber$1 || alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$1)</span><br></pre></td></tr></table></figure>
<p><code>currentlyRenderingFiber</code>即<code>workInProgress</code>，<code>workInProgress</code>存在代表当前处于<code>render阶段</code>。</p>
<p>触发更新时通过<code>bind</code>预先保存的<code>fiber</code>与<code>workInProgress</code>全等，代表本次更新发生于<code>FunctionComponent</code>对应<code>fiber</code>的<code>render阶段</code>。</p>
<p>所以这是一个<code>render阶段</code>触发的更新，需要标记变量<code>didScheduleRenderPhaseUpdate</code>，后续单独处理。</p>
<p>再来关注：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp; (alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>))</span><br></pre></td></tr></table></figure>
<p><code>fiber.lanes</code>保存<code>fiber</code>上存在的<code>update</code>的优先级。</p>
<p><code>fiber.lanes === NoLanes</code>意味着<code>fiber</code>上不存在`update``。</p>
<p>我们已经知道，通过<code>update</code>计算<code>state</code>发生在声明阶段，这是因为该<code>hook</code>上可能存在多个不同优先级的<code>update</code>，最终<code>state</code>的值由多个<code>update</code>共同决定。</p>
<p>但是当<code>fiber</code>上不存在<code>update</code>，则调用阶段创建的<code>update</code>为该<code>hook</code>上第一个<code>update</code>，在声明阶段计算<code>state</code>时也只依赖于该<code>update</code>，完全不需要进入声明阶段再计算<code>state</code>。</p>
<p>这样做的好处是：如果计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>一致，那么完全不需要开启一次调度。即使计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>不一致，在声明阶段也可以直接使用调用阶段已经计算出的<code>state</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1727">这里</a>看到这段提前计算<code>state</code>的逻辑</p>
</blockquote>
<h4 id="小-tip">小 Tip</h4>
<p>我们通常认为，<code>useReducer(reducer, initialState)</code>的传参为初始化参数，在以后的调用中都不可变。</p>
<p>但是在<code>updateReducer</code>方法中，可以看到<code>lastRenderedReducer</code>在每次调用时都会重新赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateReducer</span>(<span class="params">reducer, initialArg, init</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>也就是说，<code>reducer</code>参数是随时可变的。</p>
<p><code>reducer</code> 可变 <a
target="_blank" rel="noopener" href="https://codesandbox.io/s/romantic-rain-bmzcp?file=/src/index.js">Demo</a></p>
<p>每秒<code>useReducer</code>使用的<code>reducer</code>会改变一次</p>
<p>点击按钮后会随时间不同会出现+1或-1的效果</p>
<h3 id="useeffect">useEffect</h3>
<p>在架构篇<code>commit阶段</code>流程概览我们讲解了<code>useEffect</code>的工作流程。</p>
<p>其中我们谈到</p>
<blockquote>
<p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>
</blockquote>
<p>本节我们深入<code>flushPassiveEffects</code>方法内部探索<code>useEffect</code>的工作原理。</p>
<h4 id="flushpassiveeffectsimpl">flushPassiveEffectsImpl</h4>
<p><code>flushPassiveEffects</code>内部会设置优先级，并执行<code>flushPassiveEffectsImpl</code>。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2458">这里</a>看到<code>flushPassiveEffects</code>的代码</p>
</blockquote>
<p><code>flushPassiveEffectsImpl</code>主要做三件事：</p>
<ul>
<li>调用该<code>useEffect</code>在上一次<code>render</code>时的销毁函数</li>
<li>调用该<code>useEffect</code>在本次<code>render</code>时的回调函数</li>
<li>如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行他</li>
</ul>
<p>本节我们关注前两步。</p>
<p>在v16中第一步是同步执行的，在<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing">官方博客</a>中提到：</p>
<blockquote>
<p>副作用清理函数（如果存在）在 React 16
中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。</p>
</blockquote>
<p>基于这个原因，在v17.0.0中，<code>useEffect</code>的两个阶段会在页面渲染后（<code>layout阶段</code>后）异步执行。</p>
<blockquote>
<p>事实上，从代码中看，v16.13.1中已经是异步执行了</p>
</blockquote>
<p>接下来我们详细讲解这两个步骤。</p>
<h4 id="阶段一销毁函数的执行">阶段一：销毁函数的执行</h4>
<p>useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。</p>
<p>这是因为多个组件间可能共用同一个ref。</p>
<p>如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。</p>
<p>在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。</p>
<p>在阶段一，会遍历并执行所有useEffect的销毁函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect</span></span><br><span class="line"><span class="keyword">const</span> unmountEffects = pendingPassiveHookEffectsUnmount;</span><br><span class="line">  pendingPassiveHookEffectsUnmount = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unmountEffects.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = ((unmountEffects[i]: any): <span class="title class_">HookEffect</span>);</span><br><span class="line">    <span class="keyword">const</span> fiber = ((unmountEffects[i + <span class="number">1</span>]: any): <span class="title class_">Fiber</span>);</span><br><span class="line">    <span class="keyword">const</span> destroy = effect.<span class="property">destroy</span>;</span><br><span class="line">    effect.<span class="property">destroy</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> destroy === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 销毁函数存在则执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">destroy</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">captureCommitPhaseError</span>(fiber, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>pendingPassiveHookEffectsUnmount</code>数组的索引i保存需要销毁的<code>effect</code>，<code>i+1</code>保存该<code>effect</code>对应的<code>fiber</code>。</p>
<p>向<code>pendingPassiveHookEffectsUnmount</code>数组内<code>push</code>数据的操作发生在<code>layout阶段</code>
<code>commitLayoutEffectOnFiber</code>方法内部的<code>schedulePassiveEffects</code>方法中。</p>
<blockquote>
<p><code>commitLayoutEffectOnFiber</code>方法我们在<code>Layout阶段</code>已经介绍</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">schedulePassiveEffects</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">updateQueue</span>: <span class="title class_">FunctionComponentUpdateQueue</span> | <span class="literal">null</span> = (finishedWork.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.<span class="property">lastEffect</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;next, tag&#125; = effect;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (tag &amp; <span class="title class_">HookPassive</span>) !== <span class="title class_">NoHookEffect</span> &amp;&amp;</span><br><span class="line">        (tag &amp; <span class="title class_">HookHasEffect</span>) !== <span class="title class_">NoHookEffect</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect</span></span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectUnmount</span>(finishedWork, effect);</span><br><span class="line">        <span class="comment">// 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect</span></span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectMount</span>(finishedWork, effect);</span><br><span class="line">      &#125;</span><br><span class="line">      effect = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阶段二回调函数的执行">阶段二：回调函数的执行</h4>
<p>与阶段一类似，同样遍历数组，执行对应<code>effect</code>的回调函数。</p>
<p>其中向<code>pendingPassiveHookEffectsMount</code>中<code>push</code>数据的操作同样发生在<code>schedulePassiveEffects</code>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect</span></span><br><span class="line"><span class="keyword">const</span> mountEffects = pendingPassiveHookEffectsMount;</span><br><span class="line">pendingPassiveHookEffectsMount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mountEffects.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = ((mountEffects[i]: any): <span class="title class_">HookEffect</span>);</span><br><span class="line">  <span class="keyword">const</span> fiber = ((mountEffects[i + <span class="number">1</span>]: any): <span class="title class_">Fiber</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> create = effect.<span class="property">create</span>;</span><br><span class="line">   effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">captureCommitPhaseError</span>(fiber, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useref">useRef</h3>
<p><code>ref</code>是<code>reference</code>（引用）的缩写。<code>在React</code>中，我们习惯用<code>ref</code>保存<code>DOM</code>。</p>
<p>事实上，任何需要被"引用"的数据都可以保存在<code>ref</code>中，<code>useRef</code>的出现将这种思想进一步发扬光大。</p>
<p>在<code>Hooks</code>数据结构一节我们讲到：</p>
<blockquote>
<p>对于<code>useRef(1)</code>，<code>memoizedState</code>保存<code>&#123;current: 1&#125;</code></p>
</blockquote>
<p>本节我们会介绍<code>useRef</code>的实现，以及<code>ref</code>的工作流程。</p>
<p>由于<code>string</code>类型的<code>ref</code>已不推荐使用，所以本节针对<code>function</code>
| <code>&#123;current: any&#125;</code>类型的<code>ref</code>。</p>
<h4 id="useref-1">useRef</h4>
<p>与其他Hook一样，对于mount与update，useRef对应两个不同dispatcher。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mountRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;|<span class="attr">current</span>: T|&#125; &#123;</span><br><span class="line">  <span class="comment">// 获取当前useRef hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 创建ref</span></span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;|<span class="attr">current</span>: T|&#125; &#123;</span><br><span class="line">  <span class="comment">// 获取当前useRef hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 返回保存的数据</span></span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L1208-L1221">这里</a>看到这段代码</p>
</blockquote>
<p>可见，<code>useRef</code>仅仅是返回一个包含<code>current</code>属性的对象。</p>
<p>为了验证这个观点，我们再看下<code>React.createRef</code>方法的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params"></span>): <span class="title class_">RefObject</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;你可以从这里看到这段代码</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactCreateRef.js">这里</a>看到这段代码</p>
</blockquote>
<p>了解了<code>ref</code>的数据结构后，我们再来看看<code>ref</code>的工作流程。</p>
<h4 id="ref的工作流程">ref的工作流程</h4>
<p>在<code>React</code>中，<code>HostComponent</code>、<code>ClassComponent</code>、<code>ForwardRef</code>可以赋值<code>ref</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostComponent</span></span><br><span class="line">&lt;div ref=&#123;domRef&#125;&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// ClassComponent / ForwardRef</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">ref</span>=<span class="string">&#123;cpnRef&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>ForwardRef</code>只是将<code>ref</code>作为第二个参数传递下去，不会进入<code>ref</code>的工作流程。</p>
<p>所以接下来讨论<code>ref</code>的工作流程时会排除<code>ForwardRef</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于ForwardRef，secondArg为传递下去的ref</span></span><br><span class="line"><span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L415">这里</a>看到这段代码</p>
</blockquote>
<p>我们知道<code>HostComponent</code>在<code>commit阶段</code>的<code>mutation阶段</code>执行DOM操作。</p>
<p>所以，对应<code>ref</code>的更新也是发生在<code>mutation阶段</code>。</p>
<p>再进一步，<code>mutation阶段</code>执行<code>DOM</code>操作的依据为<code>effectTag</code>。</p>
<p>所以，对于<code>HostComponent</code>、<code>ClassComponent</code>如果包含<code>ref</code>操作，那么也会赋值相应的<code>effectTag</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*                    */</span> <span class="number">0b0000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                       */</span> <span class="number">0b0000000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*                     */</span> <span class="number">0b0000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                          */</span> <span class="number">0b0000000010000000</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js#L24">ReactSideEffectTags</a>文件中看到ref对应的effectTag</p>
</blockquote>
<p>所以，<code>ref</code>的工作流程可以分为两部分：</p>
<ul>
<li><code>render阶段</code>为含有<code>ref</code>属性的<code>fiber</code>添加<code>Ref effectTag</code></li>
<li><code>commit阶段</code>为包含<code>Ref effectTag</code>的<code>fiber</code>执行对应操作</li>
</ul>
<h4 id="render阶段">render阶段</h4>
<p>在<code>render阶段</code>的<code>beginWork</code>与<code>completeWork</code>中有个同名方法<code>markRef</code>用于为含有<code>ref</code>属性的<code>fiber</code>增加<code>Ref effectTag</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beginWork的markRef</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markRef</span>(<span class="params">current: Fiber | <span class="literal">null</span>, workInProgress: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> &amp;&amp; ref !== <span class="literal">null</span>) ||</span><br><span class="line">    (current !== <span class="literal">null</span> &amp;&amp; current.<span class="property">ref</span> !== ref)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Schedule a Ref effect</span></span><br><span class="line">    workInProgress.<span class="property">effectTag</span> |= <span class="title class_">Ref</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// completeWork的markRef</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markRef</span>(<span class="params">workInProgress: Fiber</span>) &#123;</span><br><span class="line">  workInProgress.<span class="property">effectTag</span> |= <span class="title class_">Ref</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L693">这里</a>看到beginWork的markRef、<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L153">这里</a>看到completeWork的markRef</p>
</blockquote>
<p>在<code>beginWork</code>中，如下两处调用了<code>markRef</code>：</p>
<ul>
<li>updateClassComponent内的<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L958">finishClassComponent</a>，对应ClassComponent</li>
</ul>
<p>注意<code>ClassComponent</code>即使<code>shouldComponentUpdate</code>为<code>false</code>该组件也会调用<code>markRef</code></p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L1156">updateHostComponent</a>，对应HostComponent</li>
</ul>
<p>在<code>completeWork</code>中，如下两处调用了<code>markRef</code>：</p>
<ul>
<li>completeWork中的<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L728">HostComponent</a>类型</li>
<li>completeWork中的<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L1278">ScopeComponent</a>类型</li>
</ul>
<blockquote>
<p><code>ScopeComponent</code>是一种用于管理<code>focus</code>的测试特性，详见<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/16587">PR</a></p>
</blockquote>
<p>总结下组件对应<code>fiber</code>被赋值<code>Ref effectTag</code>需要满足的条件：</p>
<ul>
<li><code>fiber</code>类型为<code>HostComponent</code>、<code>ClassComponent</code>、<code>ScopeComponent</code>（这种情况我们不讨论）</li>
<li>对于<code>mount</code>，<code>workInProgress.ref !== null</code>，即存在<code>ref</code>属性</li>
<li>对于<code>update</code>，<code>current.ref !== workInProgress.ref</code>，即<code>ref</code>属性改变</li>
</ul>
<h4 id="commit阶段">commit阶段</h4>
<p>在<code>commit阶段</code>的<code>mutation阶段</code>中，对于<code>ref</code>属性改变的情况，需要先移除之前的<code>ref</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除之前的ref</span></span><br><span class="line">        <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2342">这里</a>看到这段代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitDetachRef</span>(<span class="params">current: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> currentRef = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (currentRef !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> currentRef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// function类型ref，调用他，传参为null</span></span><br><span class="line">      <span class="title function_">currentRef</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对象类型ref，current赋值为null</span></span><br><span class="line">      currentRef.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在<code>mutation阶段</code>，对于<code>Deletion effectTag</code>的<code>fiber</code>（对应需要删除的<code>DOM节点</code>），需要递归他的子树，对子孙<code>fiber</code>的<code>ref</code>执行类似<code>commitDetachRef</code>的操作。</p>
<p>在<code>mutation阶段</code>一节我们讲到</p>
<blockquote>
<p>对于<code>Deletion effectTag</code>的<code>fiber</code>，会执行<code>commitDeletion</code>。</p>
</blockquote>
<p>在<code>commitDeletion——unmountHostComponents——commitUnmount——ClassComponent</code>
|
<code>HostComponent</code>类型<code>case</code>中调用的<code>safelyDetachRef</code>方法负责执行类似<code>commitDetachRef</code>的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safelyDetachRef</span>(<span class="params">current: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (refError) &#123;</span><br><span class="line">        <span class="title function_">captureCommitPhaseError</span>(current, refError);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L183">这里</a>看到这段代码</p>
</blockquote>
<p>接下来进入<code>ref</code>的赋值阶段。我们在<code>Layout阶段</code>一节讲到</p>
<blockquote>
<p><code>commitLayoutEffect</code>会执行<code>commitAttachRef</code>（赋值<code>ref</code>）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取ref属性对应的Component实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">        instanceToUse = <span class="title function_">getPublicInstance</span>(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值ref</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">ref</span>(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，<code>ref</code>的工作流程完毕。</p>
<h4 id="总结-13">总结</h4>
<p>本节我们学习了<code>ref</code>的工作流程。</p>
<ul>
<li>对于<code>FunctionComponent</code>，<code>useRef</code>负责创建并返回对应的<code>ref</code>。</li>
<li>对于赋值了<code>ref</code>属性的<code>HostComponent</code>与<code>ClassComponent</code>，会在<code>render阶段</code>经历赋值<code>Ref effectTag</code>，在<code>commit阶段</code>执行对应<code>ref</code>操作。</li>
</ul>
<h3 id="usememo与usecallback">useMemo与useCallback</h3>
<p>在了解其他<code>hook</code>的实现后，理解<code>useMemo与useCallback</code>的实现非常容易。</p>
<p>本节我们以<code>mount</code>与<code>update</code>两种情况分别讨论这两个hook。</p>
<h4 id="mount">mount</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mountMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 计算value</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  <span class="comment">// 将value与deps保存在hook.memoizedState</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 将value与deps保存在hook.memoizedState</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，与<code>mountCallback</code>这两个唯一的区别是</p>
<ul>
<li>mountMemo会将回调函数(<code>nextCreate</code>)的执行结果作为<code>value</code>保存</li>
<li>mountCallback会将回调函数作为<code>value</code>保存</li>
</ul>
<h4 id="update-1">update</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 判断update前后value是否变化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 未变化</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变化，重新计算value</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 判断update前后value是否变化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 未变化</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变化，将新的callback作为value</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，对于<code>update</code>，这两个<code>hook</code>的唯一区别也是是<strong>回调函数本身还是回调函数的执行结果作为value</strong>。</p>
<h2 id="第八章-concurrent-mode">第八章 Concurrent Mode</h2>
<h3 id="概览-5">概览</h3>
<p>在<code>ReactDOM.render</code>一节我们介绍了React当前的三种入口函数。日常开发主要使用的是<code>Legacy Mode</code>（通过<code>ReactDOM.render</code>创建）。</p>
<p>从<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zrrqldzRbcPApga_Cp2b8A">React
v17.0
正式发布！</a>一文可以看到，v17.0没有包含新特性。究其原因，v17.0主要的工作在于源码内部对Concurrent
Mode的支持。所以v17版本也被称为“垫脚石”版本。</p>
<p>你可以从官网<a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html">Concurrent
模式介绍</a>了解其基本概念。</p>
<p>一句话概括：</p>
<blockquote>
<p><code>Concurrent</code> 模式是一组 <code>React</code>
的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p>
</blockquote>
<p><code>Concurrent Mode</code>是<code>React</code>过去2年重构<code>Fiber架构</code>的源动力，也是React未来的发展方向。</p>
<p>可以预见，当v17完美支持<code>Concurrent Mode</code>后，v18会迎来一大波基于<code>Concurrent Mode</code>的库。</p>
<p>底层基础决定了上层API的实现，接下来让我们了解下，<code>Concurrent Mode</code>自底向上都包含哪些组成部分，能够发挥哪些能力？</p>
<h4 id="底层架构-fiber架构">底层架构 —— Fiber架构</h4>
<p>从设计理念我们了解到要实现<code>Concurrent Mode</code>，最关键的一点是：实现异步可中断的更新。</p>
<p>基于这个前提，<code>React</code>花费2年时间重构完成了<code>Fiber架构</code>。</p>
<p><code>Fiber架构</code>的意义在于，他将单个组件作为工作单元，使以组件为粒度的“异步可中断的更新”成为可能。</p>
<h4 id="架构的驱动力-scheduler">架构的驱动力 —— Scheduler</h4>
<p>如果我们同步运行<code>Fiber架构</code>（通过<code>ReactDOM.render</code>），则<code>Fiber架构</code>与重构前并无区别。</p>
<p>但是当我们配合时间切片，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现“异步可中断的更新”。</p>
<p>于是，<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/tree/master/packages/scheduler">scheduler</a>（调度器）产生了。</p>
<h4 id="架构运行策略-lane模型">架构运行策略 —— lane模型</h4>
<p>到目前为止，React可以控制更新在Fiber架构中运行/中断/继续运行。</p>
<p>基于当前的架构，当一次更新在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”。</p>
<p>当一次更新在运行过程中被中断，转而重新开始一次新的更新，我们可以说：后一次更新打断了前一次更新。</p>
<p>这就是优先级的概念：后一次更新的优先级更高，他打断了正在进行的前一次更新。</p>
<p>多个优先级之间如何互相打断？优先级能否升降？本次更新应该赋予什么优先级？</p>
<p>这就需要一个模型控制不同优先级之间的关系与行为，于是<code>lane模型</code>诞生了。</p>
<h4 id="上层实现">上层实现</h4>
<p>现在，我们可以说：</p>
<blockquote>
<p>从源码层面讲，<code>Concurrent Mode</code>是一套可控的“多优先级更新架构”。</p>
</blockquote>
<p>那么基于该架构之上可以实现哪些有意思的功能？我们举几个例子：</p>
<h5 id="batchedupdates">batchedUpdates</h5>
<p>如果我们在一次事件回调中触发多次更新，他们会被合并为一次更新进行处理。</p>
<p>如下代码执行只会触发一次更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">stateA</span>: <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">stateB</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">stateA</span>: <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种合并多个更新的优化方式被称为<code>batchedUpdates</code>。</p>
<p><code>batchedUpdates</code>在很早的版本就存在了，不过之前的实现局限很多（脱离当前上下文环境的更新不会被合并）。</p>
<p>在<code>Concurrent Mode</code>中，是以优先级为依据对更新进行合并的，使用范围更广。</p>
<h5 id="suspense">Suspense</h5>
<p><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html">Suspense</a>可以在组件请求数据时展示一个pending状态。请求成功后渲染数据。</p>
<p>本质上讲Suspense内的组件子树比组件树的其他部分拥有更低的优先级。</p>
<h5 id="usedeferredvalue">useDeferredValue</h5>
<p><a
target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue">useDeferredValue</a>返回一个延迟响应的值，该值可能“延后”的最长时间为timeoutMs。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deferredValue = <span class="title function_">useDeferredValue</span>(value, &#123; <span class="attr">timeoutMs</span>: <span class="number">2000</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在<code>useDeferredValue</code>内部会调用<code>useState</code>并触发一次更新。</p>
<p>这次更新的优先级很低，所以当前如果有正在进行中的更新，不会受<code>useDeferredValue</code>产生的更新影响。所以<code>useDeferredValue</code>能够返回延迟的值。</p>
<p>当超过<code>timeoutMs</code>后<code>useDeferredValue</code>产生的更新还没进行（由于优先级太低一直被打断），则会再触发一次高优先级更新。</p>
<h4 id="总结-14">总结</h4>
<p>除了以上介绍的实现，相信未来<code>React</code>还会开发更多基于<code>Concurrent Mode</code>的玩法。</p>
<p><code>Fiber</code>架构在之前的章节已经学习了。所以，在本章接下来的部分，我们会按照上文的脉络，自底向上，从架构到实现讲解<code>Concurrent Mode</code>。</p>
<h3 id="scheduler的原理与实现">Scheduler的原理与实现</h3>
<p>在新的<code>React</code>架构一节我们介绍了<code>Scheduler</code>，他包含两个功能：</p>
<ul>
<li>时间切片</li>
<li>优先级调度</li>
</ul>
<p>本节我们学习这个两个功能是如何在<code>Scheduler</code>中实现的。</p>
<h4 id="时间切片原理">时间切片原理</h4>
<p>时间切片的本质是模拟实现<a
target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">requestIdleCallback</a>。</p>
<p>除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行<code>JS</code>的时机。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个<span class="title function_">task</span>(宏任务) -- 队列中全部<span class="title function_">job</span>(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback</span><br></pre></td></tr></table></figure>
<p><code>requestIdleCallback</code>是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。</p>
<p>浏览器并没有提供其他<code>API</code>能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。</p>
<p>唯一能精准控制调用时机的<code>API</code>是<code>requestAnimationFrame</code>，他能让我们在“浏览器重排/重绘”之前执行<code>JS</code>。</p>
<p>这也是为什么我们通常用这个<code>API</code>实现<code>JS</code>动画 ——
这是浏览器渲染前的最后时机，所以动画能快速被渲染。</p>
<p>所以，退而求其次，<code>Scheduler</code>的时间切片功能是通过<code>task</code>（宏任务）实现的。</p>
<p>最常见的<code>task</code>当属<code>setTimeout</code>了。但是有个<code>task</code>比<code>setTimeout</code>执行时机更靠前，那就是<a
target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel">MessageChannel</a>。</p>
<p>所以<code>Scheduler</code>将需要被执行的回调函数作为<code>MessageChannel</code>的回调执行。如果当前宿主环境不支持<code>MessageChannel</code>，则使用<code>setTimeout</code>。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234">这里</a>看到MessageChannel的实现。<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55">这里</a>看到setTimeout的实现</p>
</blockquote>
<p>在<code>React</code>的<code>render阶段</code>，开启<code>Concurrent Mode</code>时，每次遍历前，都会通过<code>Scheduler</code>提供的<code>shouldYield</code>方法判断是否需要中断遍历，使浏览器有时间渲染：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。</p>
<p>在<code>Schdeduler</code>中，为任务分配的初始剩余时间为<code>5ms</code>。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119">这里</a>看到初始剩余时间的定义</p>
</blockquote>
<p>随着应用运行，会通过<code>fps</code>动态调整分配给任务的可执行时间。</p>
<blockquote>
<p>你可以从<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L172-L187">这里</a>看到动态分配任务时间</p>
</blockquote>
<p>这也解释了为什么设计理念一节启用<code>Concurrent Mode</code>后每个任务的执行时间大体都是多于<code>5ms</code>的一小段时间
——
每个时间切片被设定为<code>5ms</code>，任务本身再执行一小段时间，所以整体时间是多于<code>5ms</code>的时间</p>
<figure>
<img src="/img/web/react-22.png" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
-
</figcaption>
</figure>
<p>那么当<code>shouldYield</code>为<code>true</code>，以至于<code>performUnitOfWork</code>被中断后是如何重新启动的呢？我们会在介绍完"优先级调度"后解答。</p>
<h4 id="优先级调度">优先级调度</h4>
<p>首先我们来了解优先级的来源。需要明确的一点是，<code>Scheduler</code>是独立于<code>React</code>的包，所以他的优先级也是独立于<code>React</code>的优先级的。</p>
<p><code>Scheduler</code>对外暴露了一个方法<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L217-L237">unstable_runWithPriority</a>。</p>
<p>这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      priorityLevel = <span class="title class_">NormalPriority</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">eventHandler</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Scheduler</code>内部存在5种优先级。</p>
<p>在<code>React</code>内部凡是涉及到优先级调度的地方，都会使用<code>unstable_runWithPriority</code>。</p>
<p>比如，我们知道<code>commit阶段</code>是同步执行的。可以看到，<code>commit阶段</code>的起点<code>commitRoot</code>方法的优先级为<code>ImmediateSchedulerPriority</code>。</p>
<p><code>ImmediateSchedulerPriority</code>即<code>ImmediatePriority</code>的别名，为最高优先级，会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> renderPriorityLevel = <span class="title function_">getCurrentPriorityLevel</span>();</span><br><span class="line">  <span class="title function_">runWithPriority</span>(</span><br><span class="line">    <span class="title class_">ImmediateSchedulerPriority</span>,</span><br><span class="line">    commitRootImpl.<span class="title function_">bind</span>(<span class="literal">null</span>, root, renderPriorityLevel),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级的意义">优先级的意义</h4>
<p><code>Scheduler</code>对外暴露最重要的方法便是<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L279-L359">unstable_scheduleCallback</a>。该方法用于以某个优先级注册回调函数。</p>
<p>比如在<code>React</code>中，之前讲过在<code>commit阶段</code>的<code>beforeMutation阶段</code>会调度<code>useEffect</code>的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">  rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的回调便是通过<code>scheduleCallback</code>调度的，优先级为<code>NormalSchedulerPriority</code>，即<code>NormalPriority</code>。</p>
<p>不同优先级意味着什么？不同优先级意味着不同时长的任务过期时间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeout;</span><br><span class="line"><span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">    timeout = <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">    timeout = <span class="variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">    timeout = <span class="variable constant_">IDLE_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">    timeout = <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    timeout = <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expirationTime = startTime + timeout;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Times out immediately</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span> = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IDLE_PRIORITY_TIMEOUT</span> = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果一个任务的优先级是<code>ImmediatePriority</code>，对应<code>IMMEDIATE_PRIORITY_TIMEOUT为-1</code>，那么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expirationTime = startTime - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>则该任务的过期时间比当前时间还短，表示他已经过期了，需要立即被执行。</p>
<h4 id="不同优先级任务的排序">不同优先级任务的排序</h4>
<p>我们已经知道优先级意味着任务的过期时间。设想一个大型<code>React</code>项目，在某一刻，存在很多不同优先级的任务，对应不同的过期时间。</p>
<p>同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为：</p>
<ul>
<li>已就绪任务</li>
<li>未就绪任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> delay = options.<span class="property">delay</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 任务被延迟</span></span><br><span class="line">     startTime = currentTime + delay;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     startTime = currentTime;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   startTime = currentTime;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以，Scheduler存在两个队列：</p>
<ul>
<li>timerQueue：保存未就绪任务</li>
<li>taskQueue：保存已就绪任务</li>
</ul>
<p>每当有新的未就绪的任务被注册，我们将其插入<code>timerQueue</code>并根据开始时间重新排列<code>timerQueue</code>中任务的顺序。</p>
<p>当<code>timerQueue</code>中有任务就绪，即<code>startTime &lt;= currentTime</code>，我们将其取出并加入<code>taskQueue</code>。</p>
<p>取出<code>taskQueue</code>中最早过期的任务并执行他。</p>
<p>为了能在<code>O(1)</code>复杂度找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/lanhaicode/p/10546257.html">小顶堆</a>实现了优先级队列。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/SchedulerMinHeap.js">这里</a>看到优先级队列的实现</p>
</blockquote>
<p>至此，我们了解了<code>Scheduler</code>的实现。现在可以回答介绍时间切片时提到的问题：</p>
<blockquote>
<p>那么当<code>shouldYield</code>为<code>true</code>，以至于<code>performUnitOfWork</code>被中断后是如何重新启动的呢？</p>
</blockquote>
<p>在“取出<code>taskQueue</code>中最早过期的任务并执行他”这一步中有如下关键步骤：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> continuationCallback = <span class="title function_">callback</span>(didUserCallbackTimeout);</span><br><span class="line">currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// continuationCallback是函数</span></span><br><span class="line">  currentTask.<span class="property">callback</span> = continuationCallback;</span><br><span class="line">  <span class="title function_">markTaskYield</span>(currentTask, currentTime);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    <span class="title function_">markTaskCompleted</span>(currentTask, currentTime);</span><br><span class="line">    currentTask.<span class="property">isQueued</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentTask === <span class="title function_">peek</span>(taskQueue)) &#123;</span><br><span class="line">    <span class="comment">// 将当前任务清除</span></span><br><span class="line">    <span class="title function_">pop</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">advanceTimers</span>(currentTime);</span><br></pre></td></tr></table></figure>
<p>当注册的回调函数执行后的返回值<code>continuationCallback</code>为<code>function</code>，会将<code>continuationCallback</code>作为当前任务的回调函数。</p>
<p>如果返回值不是<code>function</code>，则将当前被执行的任务清除出<code>taskQueue</code>。</p>
<p><code>render阶段</code>被调度的函数为<code>performConcurrentWorkOnRoot</code>，在该函数末尾有这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.<span class="property">callbackNode</span> === originalCallbackNode) &#123;</span><br><span class="line">  <span class="comment">// The task node scheduled for this root is the same one that&#x27;s</span></span><br><span class="line">  <span class="comment">// currently executed. Need to return a continuation.</span></span><br><span class="line">  <span class="keyword">return</span> performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在满足一定条件时，该函数会将自己作为返回值。</p>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L850-L854">这里</a>看到这段代码</p>
</blockquote>
<h4 id="总结-15">总结</h4>
<p>刚才我们讲到，<code>Scheduler</code>与<code>React</code>是两套优先级机制。那么<code>React</code>中的优先级是如何运转的？我们会在下一节介绍。</p>
<h3 id="lane模型">lane模型</h3>
<p>上一节我们提到<code>Scheduler</code>与<code>React</code>是两套优先级机制。在<code>React</code>中，存在多种使用不同优先级的情况，比如：</p>
<p>注：以下例子皆为<code>Concurrent Mode</code>开启情况</p>
<ul>
<li>过期任务或者同步任务使用同步优先级</li>
<li>用户交互产生的更新（比如点击事件）使用高优先级</li>
<li>网络请求产生的更新使用一般优先级</li>
<li><code>Suspense</code>使用低优先级</li>
</ul>
<p><code>React</code>需要设计一套满足如下需要的优先级机制：</p>
<ul>
<li>可以表示优先级的不同</li>
<li>可能同时存在几个同优先级的更新，所以还得能表示批的概念</li>
<li>方便进行优先级相关计算</li>
</ul>
<p>为了满足如上需求，<code>React</code>设计了<code>lane模型</code>。接下来我们来看<code>lane模型</code>如何满足以上3个条件。</p>
<h4 id="表示优先级的不同">表示优先级的不同</h4>
<p>想象你身处赛车场。</p>
<figure>
<img src="/img/web/react-01.jpeg" width="90%" loading="lazy" />
<figcaption style="text-align: center;">
赛车场
</figcaption>
</figure>
<p>不同的赛车疾驰在不同的赛道。内圈的赛道总长度更短，外圈更长。某几个临近的赛道的长度可以看作差不多长。</p>
<p>lane模型借鉴了同样的概念，使用31位的二进制表示31条赛道，位数越小的赛道优先级越高，某些相邻的赛道拥有相同优先级。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SyncLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SyncBatchedLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                 */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">InputDiscreteHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*      */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputDiscreteLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000011000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*           */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                  */</span> <span class="number">0b0000000000000000000000011000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                   */</span> <span class="number">0b0000000000000000000111000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111110000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RetryLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SomeRetryLane</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                  */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SelectiveHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NonIdleLanes</span> = <span class="comment">/*                                 */</span> <span class="number">0b0000111111111111111111111111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IdleHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">IdleLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                             */</span> <span class="number">0b0110000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">OffscreenLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                   */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a
target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberLane.js#L77-L107">这里</a>看到lane的定义</p>
</blockquote>
<p>其中，同步优先级占用的赛道为第一位：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SyncLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br></pre></td></tr></table></figure>
<p>从<code>SyncLane</code>往下一直到<code>SelectiveHydrationLane</code>，赛道的优先级逐步降低。</p>
<h4 id="表示批的概念">表示“批”的概念</h4>
<p>可以看到其中有几个变量占用了几条赛道，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">InputDiscreteLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000011000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                   */</span> <span class="number">0b0000000000000000000111000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111110000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>这就是批的概念，被称作<code>lanes</code>（区别于优先级的<code>lane</code>）。</p>
<p>其中<code>InputDiscreteLanes</code>是“用户交互”触发更新会拥有的优先级范围。</p>
<p><code>DefaultLanes</code>是“请求数据返回后触发更新”拥有的优先级范围。</p>
<p><code>TransitionLanes</code>是<code>Suspense</code>、<code>useTransition</code>、<code>useDeferredValue</code>拥有的优先级范围。</p>
<p>这其中有个细节，越低优先级的<code>lanes</code>占用的位越多。比如<code>InputDiscreteLanes</code>占了2个位，<code>TransitionLanes</code>占了9个位。</p>
<p>原因在于：越低优先级的更新越容易被打断，导致积压下来，所以需要更多的位。相反，最高优的同步更新的<code>SyncLane</code>不需要多余的<code>lanes</code>。</p>
<h4 id="方便进行优先级相关计算">方便进行优先级相关计算</h4>
<p>既然<code>lane</code>对应了二进制的位，那么优先级相关计算其实就是位运算。</p>
<p>比如：</p>
<p>计算<code>a</code>、<code>b</code>两个<code>lane</code>是否存在交集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为0：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">includesSomeLane</span>(<span class="params">a: Lanes | Lane, b: Lanes | Lane</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (a &amp; b) !== <span class="title class_">NoLanes</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算<code>b</code>这个<code>lanes</code>是否是<code>a</code>对应的<code>lanes</code>的子集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为<code>b</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isSubsetOfLanes</span>(<span class="params">set: Lanes, subset: Lanes | Lane</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (set &amp; subset) === subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个<code>lane</code>或<code>lanes</code>的位合并只需要执行按位或操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mergeLanes</span>(<span class="params">a: Lanes | Lane, b: Lanes | Lane</span>): <span class="title class_">Lanes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a | b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>set</code>对应<code>lanes</code>中移除<code>subset</code>对应<code>lane</code>（或<code>lanes</code>），只需要对<code>subset</code>的<code>lane</code>（或<code>lanes</code>）执行按位非，结果再对<code>set</code>执行按位与。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">removeLanes</span>(<span class="params">set: Lanes, subset: Lanes | Lane</span>): <span class="title class_">Lanes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> set &amp; ~subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多位运算参考<a
target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">MDN</a></p>
</blockquote>
<h4 id="总结-16">总结</h4>
<p>这就是<code>React</code>的优先级模型<code>lane模型</code>。</p>
<p>至此，我们已经了解<code>Fiber</code>架构、更新的优先级、<code>Scheduler</code>的实现、<code>lane</code>模型。从下一节开始，我们会逐步讲解<code>Concurrent Mode</code>的各种应用。</p>
<h3 id="异步可中断更新">异步可中断更新</h3>
<p>后续三节内容<a
target="_blank" rel="noopener" href="https://appjiz2zqrn2142.h5.xiaoeknow.com/v1/goods/goods_detail/p_638035c1e4b07b05581d25db?type=3">视频课程</a>已更新。</p>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-full" href="/pages/system/stack-overflow/" title="栈溢出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">栈溢出</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Animenzzzzzz</div><div class="author-info-description">向来如此，便对么？</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Animenzzzzzz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Animenzzzzzz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jinnianqianyin@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">嘿咻~嘿咻~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E5%BF%B5%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">理念篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-react%E7%9A%84%E7%90%86%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">第一章 React的理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#react-%E7%90%86%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">React 理念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E7%9A%84%E7%93%B6%E9%A2%88"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">CPU 的瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-%E7%9A%84%E7%93%B6%E9%A2%88"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">IO 的瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%9A%84react%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">老的React架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react15-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">React15 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#reconciler%E5%8D%8F%E8%B0%83%E5%99%A8"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">Reconciler（协调器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#renderer%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">Renderer（渲染器）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react15-%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">React15 架构的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9B%B4%E6%96%B0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">递归更新的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84react%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">新的React架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react16-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">React16 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#scheduler%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">Scheduler（调度器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reconciler%E5%8D%8F%E8%B0%83%E5%99%A8-1"><span class="toc-number">2.1.3.1.2.</span> <span class="toc-text">Reconciler（协调器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#renderer%E6%B8%B2%E6%9F%93%E5%99%A8-1"><span class="toc-number">2.1.3.1.3.</span> <span class="toc-text">Renderer（渲染器）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">Fiber架构的心智模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">什么是代数效应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%E5%9C%A8react%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">代数效应在React中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%E4%B8%8Egenerator"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">代数效应与Generator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94%E4%B8%8Efiber"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">代数效应与Fiber</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.5.</span> <span class="toc-text">Fiber架构的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fiber%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">Fiber的起源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fiber%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">Fiber的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fiber%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">Fiber的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%9E%B6%E6%9E%84%E6%9D%A5%E8%AF%B4"><span class="toc-number">2.1.5.3.1.</span> <span class="toc-text">作为架构来说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.5.3.2.</span> <span class="toc-text">作为静态的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%8A%A8%E6%80%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83"><span class="toc-number">2.1.5.3.3.</span> <span class="toc-text">作为动态的工作单元</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-2"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.6.</span> <span class="toc-text">Fiber架构的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">什么是“双缓存”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%AD%98-fiber-%E6%A0%91"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">双缓存 Fiber 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount-%E6%97%B6"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">mount 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-%E6%97%B6"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">update 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">2.1.6.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-3"><span class="toc-number">2.1.6.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">2.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">第二章 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">源码的文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">顶层目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#packages%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">packages目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">调试源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">拉取源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">创建项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jsx"><span class="toc-number">2.2.3.</span> <span class="toc-text">深入理解JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jsx-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">JSX 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react.createelement"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">React.createElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-component"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">React Component</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsx-%E4%B8%8E-fiber-%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">JSX 与 Fiber 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-4"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">架构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-render%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">第三章 render阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="toc-number">3.1.1.</span> <span class="toc-text">流程概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">“递”阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">“归”阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-5"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beginwork"><span class="toc-number">3.1.2.</span> <span class="toc-text">beginWork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%A7%88"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">方法概览</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E4%BC%A0%E5%8F%82%E7%9C%8B%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">从传参看方法执行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-%E6%97%B6-1"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">update 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount-%E6%97%B6-1"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">mount 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reconcilechildren"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">reconcileChildren</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#effecttag"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">effectTag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-6"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completework"><span class="toc-number">3.1.3.</span> <span class="toc-text">completeWork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-1"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">流程概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86-hostcomponent"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">处理 HostComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-%E6%97%B6-2"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">update 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount-%E6%97%B6-2"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">mount 时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#effectlist"><span class="toc-number">3.1.3.5.</span> <span class="toc-text">effectList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%BB%93%E5%B0%BE"><span class="toc-number">3.1.3.6.</span> <span class="toc-text">流程结尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-7"><span class="toc-number">3.1.3.7.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-commit%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.</span> <span class="toc-text">第四章 commit阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">流程概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#before-mutation-%E4%B9%8B%E5%89%8D"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">before mutation 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#layout-%E4%B9%8B%E5%90%8E"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">layout 之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#before-mutation%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">before mutation阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitbeforemutationeffects"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">commitBeforeMutationEffects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8getsnapshotbeforeupdate"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">调用getSnapshotBeforeUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6useeffect"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">调度useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.2.4.1.</span> <span class="toc-text">如何异步调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.2.4.2.</span> <span class="toc-text">为什么需要异步调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutation%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.3.</span> <span class="toc-text">mutation阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitmutationeffects"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">commitMutationEffects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#placement-effect"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">Placement effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-effect"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">Update effect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#functioncomponent-mutation"><span class="toc-number">3.2.3.4.1.</span> <span class="toc-text">FunctionComponent mutation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hostcomponent-mutation"><span class="toc-number">3.2.3.4.2.</span> <span class="toc-text">HostComponent mutation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deletion-effect"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">Deletion effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">3.2.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#layout%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.4.</span> <span class="toc-text">layout阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-2"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitlayouteffects"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">commitLayoutEffects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitlayouteffectonfiber"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">commitLayoutEffectOnFiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitattachref"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">commitAttachRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#current-fiber%E6%A0%91%E5%88%87%E6%8D%A2"><span class="toc-number">3.2.4.5.</span> <span class="toc-text">current Fiber树切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">3.2.4.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-8"><span class="toc-number">3.2.4.7.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">实现篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-diff%E7%AE%97%E6%B3%95%E9%80%89%E8%AF%BB"><span class="toc-number">4.1.</span> <span class="toc-text">第五章 Diff算法（选读）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-3"><span class="toc-number">4.1.1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#diff%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8Areact%E5%A6%82%E4%BD%95%E5%BA%94"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Diff的瓶颈以及React如何应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">Diff是如何实现的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9diff"><span class="toc-number">4.1.2.</span> <span class="toc-text">单节点Diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">4.1.3.</span> <span class="toc-text">练习题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9diff"><span class="toc-number">4.1.4.</span> <span class="toc-text">多节点Diff</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-4"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">Diff的思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">第一轮遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%E8%B7%B3%E5%87%BA%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.4.3.1.</span> <span class="toc-text">步骤3跳出的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A44%E8%B7%B3%E5%87%BA%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.4.3.2.</span> <span class="toc-text">步骤4跳出的遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.4.4.</span> <span class="toc-text">第二轮遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.5.</span> <span class="toc-text">处理移动的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E7%A7%BB%E5%8A%A8"><span class="toc-number">4.1.6.</span> <span class="toc-text">标记节点是否移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo1"><span class="toc-number">4.1.7.</span> <span class="toc-text">Demo1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo2"><span class="toc-number">4.1.8.</span> <span class="toc-text">Demo2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.</span> <span class="toc-text">第六章 状态更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">流程概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">几个关键节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#render%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">render阶段的开始</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#commit%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">commit阶段的开始</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAupdate%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">创建Update对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Efiber%E5%88%B0root"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">从fiber到root</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">调度更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">4.2.1.4.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">心智模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%9A%84react"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">同步更新的React</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E7%9A%84react"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">并发更新的React</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-9"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update"><span class="toc-number">4.2.3.</span> <span class="toc-text">Update</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">Update的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">Update的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E4%B8%8Efiber%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">Update与Fiber的联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatequeue"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">updateQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">4.2.3.5.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.4.</span> <span class="toc-text">深入理解优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">什么是优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">如何调度优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%8A%B6%E6%80%81%E6%AD%A3%E7%A1%AE"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">如何保证状态正确</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81update%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">4.2.4.4.1.</span> <span class="toc-text">如何保证Update不丢失</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%8A%B6%E6%80%81%E4%BE%9D%E8%B5%96%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="toc-number">4.2.4.4.2.</span> <span class="toc-text">如何保证状态依赖的连续性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-10"><span class="toc-number">4.2.4.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reactdom.render"><span class="toc-number">4.2.5.</span> <span class="toc-text">ReactDOM.render</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAfiber"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">创建fiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAupdate"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">创建update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-4"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">流程概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.5.4.</span> <span class="toc-text">React的其他入口函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this.setstate"><span class="toc-number">4.2.6.</span> <span class="toc-text">this.setState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-5"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">流程概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this.forceupdate"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">this.forceUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-hooks"><span class="toc-number">4.3.</span> <span class="toc-text">第七章 Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hooks%E7%90%86%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">Hooks理念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Elogo%E8%81%8A%E8%B5%B7"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">从LOGO聊起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%81%E7%AE%80hooks%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">极简Hooks实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">更新是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">update 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">状态如何保存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hook-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">Hook 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-react-%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">模拟 React 调度更新流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97-state"><span class="toc-number">4.3.2.7.</span> <span class="toc-text">计算 state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1"><span class="toc-number">4.3.2.8.</span> <span class="toc-text">对触发事件进行抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF-demo"><span class="toc-number">4.3.2.9.</span> <span class="toc-text">在线 Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-react-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.2.10.</span> <span class="toc-text">与 React 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hooks%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.3.</span> <span class="toc-text">Hooks数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatcher"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">dispatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAdispatcher%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">一个dispatcher使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hook%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">Hook的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memoizedstate"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">memoizedState</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate%E4%B8%8Eusereducer"><span class="toc-number">4.3.4.</span> <span class="toc-text">useState与useReducer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-6"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">流程概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">声明阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mount-%E6%97%B6-3"><span class="toc-number">4.3.4.2.1.</span> <span class="toc-text">mount 时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#update-%E6%97%B6-3"><span class="toc-number">4.3.4.2.2.</span> <span class="toc-text">update 时</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">调用阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F-tip"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">小 Tip</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useeffect"><span class="toc-number">4.3.5.</span> <span class="toc-text">useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flushpassiveeffectsimpl"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">flushPassiveEffectsImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%E9%94%80%E6%AF%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">阶段一：销毁函数的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">阶段二：回调函数的执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useref"><span class="toc-number">4.3.6.</span> <span class="toc-text">useRef</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useref-1"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">ref的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.6.3.</span> <span class="toc-text">render阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.6.4.</span> <span class="toc-text">commit阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">4.3.6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usememo%E4%B8%8Eusecallback"><span class="toc-number">4.3.7.</span> <span class="toc-text">useMemo与useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-number">4.3.7.1.</span> <span class="toc-text">mount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-1"><span class="toc-number">4.3.7.2.</span> <span class="toc-text">update</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-concurrent-mode"><span class="toc-number">4.4.</span> <span class="toc-text">第八章 Concurrent Mode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-5"><span class="toc-number">4.4.1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84-fiber%E6%9E%B6%E6%9E%84"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">底层架构 —— Fiber架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%8A%9B-scheduler"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">架构的驱动力 —— Scheduler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%BF%90%E8%A1%8C%E7%AD%96%E7%95%A5-lane%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">架构运行策略 —— lane模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">上层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#batchedupdates"><span class="toc-number">4.4.1.4.1.</span> <span class="toc-text">batchedUpdates</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#suspense"><span class="toc-number">4.4.1.4.2.</span> <span class="toc-text">Suspense</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#usedeferredvalue"><span class="toc-number">4.4.1.4.3.</span> <span class="toc-text">useDeferredValue</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-number">4.4.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduler%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">Scheduler的原理与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">时间切片原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">优先级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">优先级的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">不同优先级任务的排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-number">4.4.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lane%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.3.</span> <span class="toc-text">lane模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">表示优先级的不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%89%B9%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">表示“批”的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E4%BE%BF%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">方便进行优先级相关计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%AF%E4%B8%AD%E6%96%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">4.4.4.</span> <span class="toc-text">异步可中断更新</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Animenzzzzzz</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({svg}) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script></div></body></html>